:::{note}
**AI Translation Notice**

This document was automatically translated by `hunyuan-turbos-latest` model, for reference only.

- Source document: kernel/ipc/signal.md

- Translation time: 2026-01-21 16:24:42

- Translation model: `hunyuan-turbos-latest`

Please report issues via [Community Channel](https://github.com/DragonOS-Community/DragonOS/issues)

:::

# Signal

:::{note}
Maintainer: Long Jin  
Email: <longjin@RinGoTek.cn>
:::

&emsp;&emsp;A signal is an inter-process communication mechanism. When a signal is sent to a specific process, it can trigger a particular behavior (such as terminating the program or executing a signal handler). Signals are asynchronous notifications sent to a process or a specific thread within the same process, used to inform it that an event has occurred. Common uses of signals include interrupting, suspending, terminating, or killing a process. When a signal is sent, the operating system interrupts the normal execution flow of the target process to deliver the signal. Execution can be interrupted during any non-atomic instruction. If the process has previously registered a signal handler, that routine is executed. Otherwise, the default signal handler is executed.

&emsp;&emsp;Signals are similar to interrupts, with the difference being that interrupts are mediated by the CPU and handled by the kernel, whereas signals are generated within the kernel (or can be generated by the kernel via system calls) and are handled by the respective process or the kernel's default handler.

## 1. Signal Handling Overview

### 1.1 Signal Sending

&emsp;&emsp;When Process A wants to send a signal to Process B, it uses the `kill(pid, signal)` interface to send the signal. The request then enters the kernel's `sys_kill()` function for processing. The kernel subsequently adds the signal to the `sigpending` in the PCB (Process Control Block) of the target process.

Schematic diagram:

```text
   ┌────────────┐
   │ Process A: │
   │            │
   │  sys_kill  │
   └──────┬─────┘
          │
          │
   ┌──────▼──────┐    ┌────────────────────┐
   │ Send Signal ├────►Add to sigpending of│
   └─────────────┘    │   process B.       │
                      └────────────────────┘

```

### 1.2 Signal Processing

&emsp;&emsp;When a process exits kernel mode, it jumps to the `do_signal()` function to check if there are any signals that need to be processed. If so, the signal processing procedure is initiated.

Signal processing procedure schematic:

```text

 ┌───────────────────────┐
 │       Process B:      │
 │                       ◄─────────────────────────────────┐
 │ Return from syscall...│                                 │
 └─────────┬─────────────┘                                 │
           │                                               │
           │                                               │
           │                ┌────────────────┐             │
     ┌─────▼─────┐ default  │                │             │
     │ do_signal ├────────► │ stop process B.│             │
     └─────┬─────┘  action  │                │             │
           │                └────────────────┘             │
           │ custom action                                 │
    ┌──────▼───────┐                                       │
    │ setup signal │                                       │
    │    frame     │                                       │
    └──────┬───────┘                                       │
           │jump to                                        │
    ┌──────▼───────┐ ┌────────────┐ sys_sigreturn ┌────────┴────────┐
    │   userland   ├─►sa_restorer ├──────────────►│Restore the stack│
    │ sig handler  │ └────────────┘               │    frame.       │
    └──────────────┘                              └─────────────────┘

```

- If the kernel checks and finds that the process has not specified a signal handler and the signal action is not "ignore," the process will be terminated.
- If the kernel determines that the signal is not ignored, the following steps occur:
    - The current kernel stack is backed up.
    - The user-mode stack frame for signal handling is set up.
    - The process returns to user mode to execute the signal handler.
    - After the signal handler finishes, it enters the __sa_restorer provided by libc and initiates the `sys_sigreturn()` system call to return to kernel mode.
    - The kernel restores the kernel stack that existed before signal processing.
    - The signal processing procedure ends, and the kernel continues with the process of returning to user mode.
- If the kernel finds that the current signal is ignored, it checks the next signal.
- If no signals need to be processed, the process returns to user mode.

## 2. Other Issues

### 2.1 Lock Ordering Convention (Important)

&emsp;&emsp;To avoid deadlocks caused by lock ordering inversions in signal-related paths, a fixed lock order must be followed:  
**Acquire sighand (shared signal state) first, then acquire sig_info (thread-private signal state).**  
No path should enter the sighand lock while holding the sig_info lock.  
If both need to be accessed simultaneously, acquire them in the above order and keep the access window as short as possible.
