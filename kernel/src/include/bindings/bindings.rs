/* automatically generated by rust-bindgen 0.61.0 */

pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __TIMESIZE: u32 = 64;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 35;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub const NULL: u32 = 0;
pub const AK_ARCH_X86_64: u32 = 1;
pub const PROC_MAX_FD_NUM: u32 = 16;
pub const STACK_SIZE: u32 = 32768;
pub const PROC_RUNNING: u32 = 1;
pub const PROC_INTERRUPTIBLE: u32 = 2;
pub const PROC_UNINTERRUPTIBLE: u32 = 4;
pub const PROC_ZOMBIE: u32 = 8;
pub const PROC_STOPPED: u32 = 16;
pub const KERNEL_CS: u32 = 8;
pub const KERNEL_DS: u32 = 16;
pub const USER_CS: u32 = 40;
pub const USER_DS: u32 = 48;
pub const CLONE_FS: u32 = 1;
pub const CLONE_SIGNAL: u32 = 2;
pub const CLONE_VM: u32 = 4;
pub const PCB_NAME_LEN: u32 = 16;
pub const PF_KTHREAD: u32 = 1;
pub const PF_NEED_SCHED: u32 = 2;
pub const PF_VFORK: u32 = 4;
pub const PF_KFORK: u32 = 8;
pub const PF_NOFREEZE: u32 = 16;
pub const PAD_ZERO: u32 = 1;
pub const LEFT: u32 = 2;
pub const RIGHT: u32 = 4;
pub const PLUS: u32 = 8;
pub const SPACE: u32 = 16;
pub const SPECIAL: u32 = 32;
pub const SMALL: u32 = 64;
pub const SIGN: u32 = 128;
pub const WHITE: u32 = 16777215;
pub const BLACK: u32 = 0;
pub const RED: u32 = 16711680;
pub const ORANGE: u32 = 16744448;
pub const YELLOW: u32 = 16776960;
pub const GREEN: u32 = 65280;
pub const BLUE: u32 = 255;
pub const INDIGO: u32 = 65535;
pub const PURPLE: u32 = 8388863;
pub const EPOS_OVERFLOW: u32 = 1;
pub const EFB_MISMATCH: u32 = 2;
pub const EUNSUPPORTED: u32 = 3;
pub const SCM_BF_FB: u32 = 1;
pub const SCM_BF_DB: u32 = 2;
pub const SCM_BF_TEXT: u32 = 4;
pub const SCM_BF_PIXEL: u32 = 8;
pub const __GNUC_VA_LIST: u32 = 1;
pub const LZ4_VERSION_MAJOR: u32 = 1;
pub const LZ4_VERSION_MINOR: u32 = 9;
pub const LZ4_VERSION_RELEASE: u32 = 3;
pub const LZ4_VERSION_NUMBER: u32 = 10903;
pub const LZ4_MEMORY_USAGE: u32 = 14;
pub const LZ4_MAX_INPUT_SIZE: u32 = 2113929216;
pub const LZ4_HASHLOG: u32 = 12;
pub const LZ4_HASHTABLESIZE: u32 = 16384;
pub const LZ4_HASH_SIZE_U32: u32 = 4096;
pub const LZ4_STREAMSIZE: u32 = 16416;
pub const MAX_SYSTEM_CALL_NUM: u32 = 256;
pub const ESYSCALL_NOT_EXISTS: u32 = 1;
pub const SYS_NOT_EXISTS: u32 = 0;
pub const SYS_PUT_STRING: u32 = 1;
pub const SYS_OPEN: u32 = 2;
pub const SYS_CLOSE: u32 = 3;
pub const SYS_READ: u32 = 4;
pub const SYS_WRITE: u32 = 5;
pub const SYS_LSEEK: u32 = 6;
pub const SYS_FORK: u32 = 7;
pub const SYS_VFORK: u32 = 8;
pub const SYS_BRK: u32 = 9;
pub const SYS_SBRK: u32 = 10;
pub const SYS_REBOOT: u32 = 11;
pub const SYS_CHDIR: u32 = 12;
pub const SYS_GET_DENTS: u32 = 13;
pub const SYS_EXECVE: u32 = 14;
pub const SYS_WAIT4: u32 = 15;
pub const SYS_EXIT: u32 = 16;
pub const SYS_MKDIR: u32 = 17;
pub const SYS_NANOSLEEP: u32 = 18;
pub const SYS_CLOCK: u32 = 19;
pub const SYS_PIPE: u32 = 20;
pub const SYS_MSTAT: u32 = 21;
pub const SYS_UNLINK_AT: u32 = 22;
pub const SYS_AHCI_END_REQ: u32 = 255;
pub const MAX_CPU_NUM: u32 = 32;
pub const E2BIG: u32 = 1;
pub const EACCES: u32 = 2;
pub const EADDRINUSE: u32 = 3;
pub const EADDRNOTAVAIL: u32 = 4;
pub const EAFNOSUPPORT: u32 = 5;
pub const EAGAIN: u32 = 6;
pub const EALREADY: u32 = 7;
pub const EBADF: u32 = 8;
pub const EBADMSG: u32 = 9;
pub const EBUSY: u32 = 10;
pub const ECANCELED: u32 = 11;
pub const ECHILD: u32 = 12;
pub const ECONNABORTED: u32 = 13;
pub const ECONNREFUSED: u32 = 14;
pub const ECONNRESET: u32 = 15;
pub const EDEADLK: u32 = 16;
pub const EDESTADDRREQ: u32 = 17;
pub const EDOM: u32 = 18;
pub const EDQUOT: u32 = 19;
pub const EEXIST: u32 = 20;
pub const EFAULT: u32 = 21;
pub const EFBIG: u32 = 22;
pub const EHOSTUNREACH: u32 = 23;
pub const EIDRM: u32 = 24;
pub const EILSEQ: u32 = 25;
pub const EINPROGRESS: u32 = 26;
pub const EINTR: u32 = 27;
pub const EINVAL: u32 = 28;
pub const EIO: u32 = 29;
pub const EISCONN: u32 = 30;
pub const EISDIR: u32 = 31;
pub const ELOOP: u32 = 32;
pub const EMFILE: u32 = 33;
pub const EMLINK: u32 = 34;
pub const EMSGSIZE: u32 = 35;
pub const EMULTIHOP: u32 = 36;
pub const ENAMETOOLONG: u32 = 37;
pub const ENETDOWN: u32 = 38;
pub const ENETRESET: u32 = 39;
pub const ENETUNREACH: u32 = 40;
pub const ENFILE: u32 = 41;
pub const ENOBUFS: u32 = 42;
pub const ENODATA: u32 = 43;
pub const ENODEV: u32 = 44;
pub const ENOENT: u32 = 45;
pub const ENOEXEC: u32 = 46;
pub const ENOLCK: u32 = 47;
pub const ENOLINK: u32 = 48;
pub const ENOMEM: u32 = 49;
pub const ENOMSG: u32 = 50;
pub const ENOPROTOOPT: u32 = 51;
pub const ENOSPC: u32 = 52;
pub const ENOSR: u32 = 53;
pub const ENOSTR: u32 = 54;
pub const ENOSYS: u32 = 55;
pub const ENOTCONN: u32 = 56;
pub const ENOTDIR: u32 = 57;
pub const ENOTEMPTY: u32 = 58;
pub const ENOTRECOVERABLE: u32 = 59;
pub const ENOTSOCK: u32 = 60;
pub const ENOTSUP: u32 = 61;
pub const ENOTTY: u32 = 62;
pub const ENXIO: u32 = 63;
pub const EOPNOTSUPP: u32 = 64;
pub const EOVERFLOW: u32 = 65;
pub const EOWNERDEAD: u32 = 66;
pub const EPERM: u32 = 67;
pub const EPIPE: u32 = 68;
pub const EPROTO: u32 = 69;
pub const EPROTONOSUPPORT: u32 = 70;
pub const EPROTOTYPE: u32 = 71;
pub const ERANGE: u32 = 72;
pub const EROFS: u32 = 73;
pub const ESPIPE: u32 = 74;
pub const ESRCH: u32 = 75;
pub const ESTALE: u32 = 76;
pub const ETIME: u32 = 77;
pub const ETIMEDOUT: u32 = 78;
pub const ETXTBSY: u32 = 79;
pub const EWOULDBLOCK: u32 = 80;
pub const EXDEV: u32 = 81;
pub const BLK_TYPE_AHCI: u32 = 0;
pub const DISK_NAME_LEN: u32 = 32;
pub const BLK_GF_AHCI: u32 = 1;
pub const O_RDONLY: u32 = 0;
pub const O_WRONLY: u32 = 1;
pub const O_RDWR: u32 = 2;
pub const O_ACCMODE: u32 = 3;
pub const O_CREAT: u32 = 64;
pub const O_EXCL: u32 = 128;
pub const O_NOCTTY: u32 = 256;
pub const O_TRUNC: u32 = 512;
pub const O_APPEND: u32 = 1024;
pub const O_NONBLOCK: u32 = 2048;
pub const O_EXEC: u32 = 4096;
pub const O_SEARCH: u32 = 8192;
pub const O_DIRECTORY: u32 = 16384;
pub const O_NOFOLLOW: u32 = 32768;
pub const AT_FDCWD: i32 = -100;
pub const AT_SYMLINK_NOFOLLOW: u32 = 256;
pub const AT_EACCESS: u32 = 512;
pub const AT_REMOVEDIR: u32 = 512;
pub const AT_SYMLINK_FOLLOW: u32 = 1024;
pub const AT_NO_AUTOMOUNT: u32 = 2048;
pub const AT_EMPTY_PATH: u32 = 4096;
pub const AT_STATX_SYNC_TYPE: u32 = 24576;
pub const AT_STATX_SYNC_AS_STAT: u32 = 0;
pub const AT_STATX_FORCE_SYNC: u32 = 8192;
pub const AT_STATX_DONT_SYNC: u32 = 16384;
pub const AT_RECURSIVE: u32 = 32768;
pub const PTRS_PER_PGT: u32 = 512;
pub const PAGE_OFFSET: i64 = -140737488355328;
pub const KERNEL_BASE_LINEAR_ADDR: i64 = -140737488355328;
pub const USER_MAX_LINEAR_ADDR: u64 = 140737488355327;
pub const MMIO_BASE: i64 = -104453604638720;
pub const MMIO_TOP: i64 = -103354093010944;
pub const PAGE_4K_SHIFT: u32 = 12;
pub const PAGE_2M_SHIFT: u32 = 21;
pub const PAGE_1G_SHIFT: u32 = 30;
pub const PAGE_GDT_SHIFT: u32 = 39;
pub const PAGE_4K_SIZE: u32 = 4096;
pub const PAGE_2M_SIZE: u32 = 2097152;
pub const PAGE_1G_SIZE: u32 = 1073741824;
pub const PAGE_4K_MASK: i32 = -4096;
pub const PAGE_2M_MASK: i32 = -2097152;
pub const SPECIAL_MEMOEY_MAPPING_VIRT_ADDR_BASE: i64 = -105553116266496;
pub const FRAME_BUFFER_MAPPING_OFFSET: u32 = 50331648;
pub const IO_APIC_MAPPING_OFFSET: u32 = 4273995776;
pub const LOCAL_APIC_MAPPING_OFFSET: u32 = 4276092928;
pub const AHCI_MAPPING_OFFSET: u32 = 4280287232;
pub const XHCI_MAPPING_OFFSET: u64 = 4294967296;
pub const ZONE_DMA: u32 = 1;
pub const ZONE_NORMAL: u32 = 2;
pub const ZONE_UNMAPPED_IN_PGT: u32 = 4;
pub const PAGE_PGT_MAPPED: u32 = 1;
pub const PAGE_KERNEL_INIT: u32 = 2;
pub const PAGE_DEVICE: u32 = 4;
pub const PAGE_KERNEL: u32 = 8;
pub const PAGE_SHARED: u32 = 16;
pub const PAGE_XD: i64 = -9223372036854775808;
pub const PAGE_PAT: u32 = 4096;
pub const PAGE_4K_PAT: u32 = 128;
pub const PAGE_GLOBAL: u32 = 256;
pub const PAGE_PS: u32 = 128;
pub const PAGE_DIRTY: u32 = 64;
pub const PAGE_ACCESSED: u32 = 32;
pub const PAGE_PCD: u32 = 16;
pub const PAGE_PWT: u32 = 8;
pub const PAGE_U_S: u32 = 4;
pub const PAGE_R_W: u32 = 2;
pub const PAGE_PRESENT: u32 = 1;
pub const PAGE_KERNEL_PGT: u32 = 3;
pub const PAGE_KERNEL_DIR: u32 = 3;
pub const PAGE_KERNEL_PDE: u32 = 3;
pub const PAGE_KERNEL_PAGE: u32 = 131;
pub const PAGE_KERNEL_4K_PAGE: u32 = 3;
pub const PAGE_USER_PGT: u32 = 7;
pub const PAGE_USER_DIR: u32 = 7;
pub const PAGE_USER_PDE: u32 = 7;
pub const PAGE_USER_PAGE: u32 = 135;
pub const PAGE_USER_4K_PAGE: u32 = 7;
pub const EPAGE_NULL: u32 = 1;
pub const VM_NONE: u32 = 0;
pub const VM_READ: u32 = 1;
pub const VM_WRITE: u32 = 2;
pub const VM_EXEC: u32 = 4;
pub const VM_SHARED: u32 = 8;
pub const VM_IO: u32 = 16;
pub const VM_SOFTDIRTY: u32 = 32;
pub const VM_MAYSHARE: u32 = 64;
pub const VM_USER: u32 = 128;
pub const VM_DONTCOPY: u32 = 256;
pub const VM_ACCESS_FLAGS: u32 = 7;
pub const ESLAB_NOTNULL: u32 = 101;
pub const ENOT_IN_SLAB: u32 = 102;
pub const ECANNOT_FREE_MEM: u32 = 103;
pub const VFS_DPT_MBR: u32 = 0;
pub const VFS_DPT_GPT: u32 = 1;
pub const VFS_MAX_PATHLEN: u32 = 1024;
pub const VFS_IF_FILE: u32 = 1;
pub const VFS_IF_DIR: u32 = 2;
pub const VFS_IF_DEVICE: u32 = 4;
pub const VFS_IF_DEAD: u32 = 8;
pub const VFS_DF_MOUNTED: u32 = 1;
pub const VFS_DF_CANNOT_MOUNT: u32 = 2;
pub const VFS_FILE_MODE_READ: u32 = 1;
pub const VFS_FILE_MODE_WRITE: u32 = 2;
pub const VFS_FILE_MODE_RW: u32 = 3;
pub const GET_CURRENT_PCB: &[u8; 39usize] = b"movq %rsp, %rbx \n\tandq $-32768, %rbx\n\t\0";
pub const SCHED_NORMAL: u32 = 0;
pub const SCHED_FIFO: u32 = 1;
pub const SCHED_RR: u32 = 2;
pub const SCHED_BATCH: u32 = 3;
pub const SCHED_IDLE: u32 = 5;
pub const SCHED_DEADLINE: u32 = 6;
pub const SCHED_MAX_POLICY_NUM: u32 = 6;
pub type __u_char = ::core::ffi::c_uchar;
pub type __u_short = ::core::ffi::c_ushort;
pub type __u_int = ::core::ffi::c_uint;
pub type __u_long = ::core::ffi::c_ulong;
pub type __int8_t = ::core::ffi::c_schar;
pub type __uint8_t = ::core::ffi::c_uchar;
pub type __int16_t = ::core::ffi::c_short;
pub type __uint16_t = ::core::ffi::c_ushort;
pub type __int32_t = ::core::ffi::c_int;
pub type __uint32_t = ::core::ffi::c_uint;
pub type __int64_t = ::core::ffi::c_long;
pub type __uint64_t = ::core::ffi::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::core::ffi::c_long;
pub type __u_quad_t = ::core::ffi::c_ulong;
pub type __intmax_t = ::core::ffi::c_long;
pub type __uintmax_t = ::core::ffi::c_ulong;
pub type __dev_t = ::core::ffi::c_ulong;
pub type __uid_t = ::core::ffi::c_uint;
pub type __gid_t = ::core::ffi::c_uint;
pub type __ino_t = ::core::ffi::c_ulong;
pub type __ino64_t = ::core::ffi::c_ulong;
pub type __mode_t = ::core::ffi::c_uint;
pub type __nlink_t = ::core::ffi::c_ulong;
pub type __off_t = ::core::ffi::c_long;
pub type __off64_t = ::core::ffi::c_long;
pub type __pid_t = ::core::ffi::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::core::ffi::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    const UNINIT: ::core::mem::MaybeUninit<__fsid_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::core::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::core::ffi::c_long;
pub type __rlim_t = ::core::ffi::c_ulong;
pub type __rlim64_t = ::core::ffi::c_ulong;
pub type __id_t = ::core::ffi::c_uint;
pub type __time_t = ::core::ffi::c_long;
pub type __useconds_t = ::core::ffi::c_uint;
pub type __suseconds_t = ::core::ffi::c_long;
pub type __suseconds64_t = ::core::ffi::c_long;
pub type __daddr_t = ::core::ffi::c_int;
pub type __key_t = ::core::ffi::c_int;
pub type __clockid_t = ::core::ffi::c_int;
pub type __timer_t = *mut ::core::ffi::c_void;
pub type __blksize_t = ::core::ffi::c_long;
pub type __blkcnt_t = ::core::ffi::c_long;
pub type __blkcnt64_t = ::core::ffi::c_long;
pub type __fsblkcnt_t = ::core::ffi::c_ulong;
pub type __fsblkcnt64_t = ::core::ffi::c_ulong;
pub type __fsfilcnt_t = ::core::ffi::c_ulong;
pub type __fsfilcnt64_t = ::core::ffi::c_ulong;
pub type __fsword_t = ::core::ffi::c_long;
pub type __ssize_t = ::core::ffi::c_long;
pub type __syscall_slong_t = ::core::ffi::c_long;
pub type __syscall_ulong_t = ::core::ffi::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::core::ffi::c_char;
pub type __intptr_t = ::core::ffi::c_long;
pub type __socklen_t = ::core::ffi::c_uint;
pub type __sig_atomic_t = ::core::ffi::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::core::ffi::c_schar;
pub type int_fast16_t = ::core::ffi::c_long;
pub type int_fast32_t = ::core::ffi::c_long;
pub type int_fast64_t = ::core::ffi::c_long;
pub type uint_fast8_t = ::core::ffi::c_uchar;
pub type uint_fast16_t = ::core::ffi::c_ulong;
pub type uint_fast32_t = ::core::ffi::c_ulong;
pub type uint_fast64_t = ::core::ffi::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type u_char = ::core::ffi::c_uchar;
pub type u_short = ::core::ffi::c_ushort;
pub type u_int = ::core::ffi::c_uint;
pub type u_long = ::core::ffi::c_ulong;
pub type uid_t = u32;
pub type gid_t = u32;
pub type caddr_t = *mut ::core::ffi::c_char;
pub type id_t = ::core::ffi::c_int;
pub type ino_t = u64;
pub type off_t = i64;
pub type blkcnt_t = u32;
pub type blksize_t = u32;
pub type dev_t = u32;
pub type mode_t = u16;
pub type nlink_t = u32;
pub type time_t = i64;
pub type useconds_t = u32;
pub type suseconds_t = i32;
pub type clock_t = u32;
pub type fsblkcnt_t = u64;
pub type fsfilcnt_t = u64;
pub type sector_t = u64;
pub type socklen_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct utimbuf {
    pub actime: time_t,
    pub modtime: time_t,
}
#[test]
fn bindgen_test_layout_utimbuf() {
    const UNINIT: ::core::mem::MaybeUninit<utimbuf> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<utimbuf>(),
        16usize,
        concat!("Size of: ", stringify!(utimbuf))
    );
    assert_eq!(
        ::core::mem::align_of::<utimbuf>(),
        8usize,
        concat!("Alignment of ", stringify!(utimbuf))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).actime) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(utimbuf),
            "::",
            stringify!(actime)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).modtime) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(utimbuf),
            "::",
            stringify!(modtime)
        )
    );
}
pub type pthread_t = ::core::ffi::c_int;
pub type pthread_key_t = ::core::ffi::c_int;
pub type pthread_once_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_mutex_t {
    pub lock: u32,
    pub owner: pthread_t,
    pub level: ::core::ffi::c_int,
    pub type_: ::core::ffi::c_int,
}
#[test]
fn bindgen_test_layout___pthread_mutex_t() {
    const UNINIT: ::core::mem::MaybeUninit<__pthread_mutex_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__pthread_mutex_t>(),
        16usize,
        concat!("Size of: ", stringify!(__pthread_mutex_t))
    );
    assert_eq!(
        ::core::mem::align_of::<__pthread_mutex_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__pthread_mutex_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).lock) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_t),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).owner) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_t),
            "::",
            stringify!(owner)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).level) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_t),
            "::",
            stringify!(level)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_t),
            "::",
            stringify!(type_)
        )
    );
}
pub type pthread_mutex_t = __pthread_mutex_t;
pub type pthread_attr_t = *mut ::core::ffi::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_mutexattr_t {
    pub type_: ::core::ffi::c_int,
}
#[test]
fn bindgen_test_layout___pthread_mutexattr_t() {
    const UNINIT: ::core::mem::MaybeUninit<__pthread_mutexattr_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__pthread_mutexattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(__pthread_mutexattr_t))
    );
    assert_eq!(
        ::core::mem::align_of::<__pthread_mutexattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutexattr_t),
            "::",
            stringify!(type_)
        )
    );
}
pub type pthread_mutexattr_t = __pthread_mutexattr_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_cond_t {
    pub mutex: *mut pthread_mutex_t,
    pub value: u32,
    pub clockid: ::core::ffi::c_int,
}
#[test]
fn bindgen_test_layout___pthread_cond_t() {
    const UNINIT: ::core::mem::MaybeUninit<__pthread_cond_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__pthread_cond_t>(),
        16usize,
        concat!("Size of: ", stringify!(__pthread_cond_t))
    );
    assert_eq!(
        ::core::mem::align_of::<__pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mutex) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_t),
            "::",
            stringify!(mutex)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_t),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).clockid) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_t),
            "::",
            stringify!(clockid)
        )
    );
}
pub type pthread_cond_t = __pthread_cond_t;
pub type pthread_rwlock_t = u64;
pub type pthread_rwlockattr_t = *mut ::core::ffi::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_spinlock_t {
    pub m_lock: ::core::ffi::c_int,
}
#[test]
fn bindgen_test_layout___pthread_spinlock_t() {
    const UNINIT: ::core::mem::MaybeUninit<__pthread_spinlock_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__pthread_spinlock_t>(),
        4usize,
        concat!("Size of: ", stringify!(__pthread_spinlock_t))
    );
    assert_eq!(
        ::core::mem::align_of::<__pthread_spinlock_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__pthread_spinlock_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).m_lock) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_spinlock_t),
            "::",
            stringify!(m_lock)
        )
    );
}
pub type pthread_spinlock_t = __pthread_spinlock_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_condattr_t {
    pub clockid: ::core::ffi::c_int,
}
#[test]
fn bindgen_test_layout___pthread_condattr_t() {
    const UNINIT: ::core::mem::MaybeUninit<__pthread_condattr_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__pthread_condattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(__pthread_condattr_t))
    );
    assert_eq!(
        ::core::mem::align_of::<__pthread_condattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__pthread_condattr_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).clockid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_condattr_t),
            "::",
            stringify!(clockid)
        )
    );
}
pub type pthread_condattr_t = __pthread_condattr_t;
pub type gfp_t = u64;
extern "C" {
    #[doc = " @brief 计算crc16"]
    #[doc = ""]
    #[doc = " @param crc crc初始值"]
    #[doc = " @param buffer 输入缓冲区"]
    #[doc = " @param len buffer大小（bytes）"]
    #[doc = " @return uint16_t crc"]
    pub fn crc16(crc: u16, buffer: *const u8, len: usize) -> u16;
}
extern "C" {
    #[doc = " @brief 计算crc32"]
    #[doc = ""]
    #[doc = " @param crc crc初始值"]
    #[doc = " @param buffer 输入缓冲区"]
    #[doc = " @param len buffer大小（bytes）"]
    #[doc = " @return uint32_t crc"]
    pub fn crc32(crc: u32, buffer: *const u8, len: usize) -> u32;
}
extern "C" {
    #[doc = " @brief 计算crc64"]
    #[doc = ""]
    #[doc = " @param crc crc初始值"]
    #[doc = " @param buffer 输入缓冲区"]
    #[doc = " @param len buffer大小（bytes）"]
    #[doc = " @return uint64_t crc"]
    pub fn crc64(crc: u64, buffer: *const u8, len: usize) -> u64;
}
extern "C" {
    #[doc = " @brief 计算crc7"]
    #[doc = ""]
    #[doc = " @param crc crc初始值"]
    #[doc = " @param buffer 输入缓冲区"]
    #[doc = " @param len buffer大小（bytes）"]
    #[doc = " @return uint8_t crc"]
    pub fn crc7(crc: u8, buffer: *const u8, len: usize) -> u8;
}
extern "C" {
    #[doc = " @brief 计算crc8"]
    #[doc = ""]
    #[doc = " @param crc crc初始值"]
    #[doc = " @param buffer 输入缓冲区"]
    #[doc = " @param len buffer大小（bytes）"]
    #[doc = " @return uint8_t crc"]
    pub fn crc8(crc: u8, buffer: *const u8, len: usize) -> u8;
}
pub type __u8_alias_t = u8;
pub type __u16_alias_t = u16;
pub type __u32_alias_t = u32;
pub type __u64_alias_t = u64;
extern "C" {
    #[doc = " @brief 读取rsp寄存器的值（存储了页目录的基地址）"]
    #[doc = ""]
    #[doc = " @return unsigned*  rsp的值的指针"]
    pub fn get_rsp() -> *mut ::core::ffi::c_ulong;
}
extern "C" {
    #[doc = " @brief 读取rbp寄存器的值（存储了页目录的基地址）"]
    #[doc = ""]
    #[doc = " @return unsigned*  rbp的值的指针"]
    pub fn get_rbp() -> *mut ::core::ffi::c_ulong;
}
extern "C" {
    #[doc = " @brief 读取ds寄存器的值（存储了页目录的基地址）"]
    #[doc = ""]
    #[doc = " @return unsigned*  ds的值的指针"]
    pub fn get_ds() -> *mut ::core::ffi::c_ulong;
}
extern "C" {
    #[doc = " @brief 读取rax寄存器的值（存储了页目录的基地址）"]
    #[doc = ""]
    #[doc = " @return unsigned*  rax的值的指针"]
    pub fn get_rax() -> *mut ::core::ffi::c_ulong;
}
extern "C" {
    #[doc = " @brief 读取rbx寄存器的值（存储了页目录的基地址）"]
    #[doc = ""]
    #[doc = " @return unsigned*  rbx的值的指针"]
    pub fn get_rbx() -> *mut ::core::ffi::c_ulong;
}
extern "C" {
    #[doc = " @brief 向msr寄存器组的address处的寄存器写入值value"]
    #[doc = ""]
    #[doc = " @param address 地址"]
    #[doc = " @param value 要写入的值"]
    pub fn wrmsr(address: u64, value: u64);
}
extern "C" {
    #[doc = " @brief 从msr寄存器组的address地址处读取值"]
    #[doc = " rdmsr返回高32bits在edx，低32bits在eax"]
    #[doc = " @param address 地址"]
    #[doc = " @return uint64_t address处的寄存器的值"]
    pub fn rdmsr(address: u64) -> u64;
}
extern "C" {
    pub fn get_rflags() -> u64;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct List {
    pub prev: *mut List,
    pub next: *mut List,
}
#[test]
fn bindgen_test_layout_List() {
    const UNINIT: ::core::mem::MaybeUninit<List> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<List>(),
        16usize,
        concat!("Size of: ", stringify!(List))
    );
    assert_eq!(
        ::core::mem::align_of::<List>(),
        8usize,
        concat!("Alignment of ", stringify!(List))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).prev) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(List),
            "::",
            stringify!(prev)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(List),
            "::",
            stringify!(next)
        )
    );
}
pub type uchar = ::core::ffi::c_uchar;
pub type ushort = ::core::ffi::c_ushort;
pub type uint = ::core::ffi::c_uint;
pub type ul = ::core::ffi::c_ulong;
pub type ull = ::core::ffi::c_ulonglong;
pub type ll = ::core::ffi::c_longlong;
extern "C" {
    pub fn round(x: f64) -> ul;
}
extern "C" {
    pub fn memset(
        dst: *mut ::core::ffi::c_void,
        C: ::core::ffi::c_uchar,
        size: ul,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn memset_c(dst: *mut ::core::ffi::c_void, c: u8, count: usize)
        -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn io_in8(port: ::core::ffi::c_ushort) -> ::core::ffi::c_uchar;
}
extern "C" {
    pub fn io_in32(port: ::core::ffi::c_ushort) -> ::core::ffi::c_uint;
}
extern "C" {
    pub fn io_out8(port: ::core::ffi::c_ushort, value: ::core::ffi::c_uchar);
}
extern "C" {
    pub fn io_out32(port: ::core::ffi::c_ushort, value: ::core::ffi::c_uint);
}
extern "C" {
    #[doc = " @brief 验证地址空间是否为用户地址空间"]
    #[doc = ""]
    #[doc = " @param addr_start 地址起始值"]
    #[doc = " @param length 地址长度"]
    #[doc = " @return true"]
    #[doc = " @return false"]
    pub fn verify_area(addr_start: u64, length: u64) -> bool;
}
extern "C" {
    #[doc = " @brief 这个函数让蜂鸣器发声，目前仅用于真机调试。未来将移除，请勿依赖此函数。"]
    #[doc = ""]
    #[doc = " @param times 发声循环多少遍"]
    pub fn __experimental_beep(times: u64);
}
extern "C" {
    #[doc = " @brief 将数据从src搬运到dst，并能正确处理地址重叠的问题"]
    #[doc = ""]
    #[doc = " @param dst 目标地址指针"]
    #[doc = " @param src 源地址指针"]
    #[doc = " @param size 大小"]
    #[doc = " @return void* 指向目标地址的指针"]
    pub fn memmove(
        dst: *mut ::core::ffi::c_void,
        src: *const ::core::ffi::c_void,
        size: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn get_current_pcb() -> *mut process_control_block;
}
#[doc = " @brief 信号量的等待队列"]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wait_queue_node_t {
    pub wait_list: List,
    pub pcb: *mut process_control_block,
}
#[test]
fn bindgen_test_layout_wait_queue_node_t() {
    const UNINIT: ::core::mem::MaybeUninit<wait_queue_node_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<wait_queue_node_t>(),
        24usize,
        concat!("Size of: ", stringify!(wait_queue_node_t))
    );
    assert_eq!(
        ::core::mem::align_of::<wait_queue_node_t>(),
        8usize,
        concat!("Alignment of ", stringify!(wait_queue_node_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).wait_list) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wait_queue_node_t),
            "::",
            stringify!(wait_list)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pcb) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wait_queue_node_t),
            "::",
            stringify!(pcb)
        )
    );
}
extern "C" {
    #[doc = " @brief 初始化等待队列"]
    #[doc = ""]
    #[doc = " @param wait_queue 等待队列"]
    #[doc = " @param pcb pcb"]
    pub fn wait_queue_init(wait_queue: *mut wait_queue_node_t, pcb: *mut process_control_block);
}
extern "C" {
    #[doc = " @brief 在等待队列上进行等待"]
    #[doc = ""]
    #[doc = " @param wait_queue_head 队列头指针"]
    pub fn wait_queue_sleep_on(wait_queue_head: *mut wait_queue_node_t);
}
extern "C" {
    #[doc = " @brief 在等待队列上进行等待,同时释放自旋锁"]
    #[doc = ""]
    #[doc = " @param wait_queue_head 队列头指针"]
    pub fn wait_queue_sleep_on_unlock(
        wait_queue_head: *mut wait_queue_node_t,
        lock: *mut ::core::ffi::c_void,
    );
}
extern "C" {
    #[doc = " @brief 在等待队列上进行等待(允许中断)"]
    #[doc = ""]
    #[doc = " @param wait_queue_head 队列头指针"]
    pub fn wait_queue_sleep_on_interriptible(wait_queue_head: *mut wait_queue_node_t);
}
extern "C" {
    #[doc = " @brief 唤醒在等待队列的头部的进程"]
    #[doc = ""]
    #[doc = " @param wait_queue_head 队列头"]
    #[doc = " @param state 要唤醒的进程的状态"]
    pub fn wait_queue_wakeup(wait_queue_head: *mut wait_queue_node_t, state: i64);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct thread_struct {
    pub rbp: ul,
    pub rip: ul,
    pub rsp: ul,
    pub fs: ul,
    pub gs: ul,
    pub cr2: ul,
    pub trap_num: ul,
    pub err_code: ul,
}
#[test]
fn bindgen_test_layout_thread_struct() {
    const UNINIT: ::core::mem::MaybeUninit<thread_struct> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<thread_struct>(),
        64usize,
        concat!("Size of: ", stringify!(thread_struct))
    );
    assert_eq!(
        ::core::mem::align_of::<thread_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(thread_struct))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rbp) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_struct),
            "::",
            stringify!(rbp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rip) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_struct),
            "::",
            stringify!(rip)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rsp) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_struct),
            "::",
            stringify!(rsp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fs) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_struct),
            "::",
            stringify!(fs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).gs) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_struct),
            "::",
            stringify!(gs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cr2) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_struct),
            "::",
            stringify!(cr2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).trap_num) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_struct),
            "::",
            stringify!(trap_num)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).err_code) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_struct),
            "::",
            stringify!(err_code)
        )
    );
}
#[doc = " @brief 进程控制块"]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct process_control_block {
    pub state: ::core::ffi::c_long,
    pub flags: ::core::ffi::c_ulong,
    pub preempt_count: i64,
    pub signal: ::core::ffi::c_long,
    pub cpu_id: ::core::ffi::c_long,
    pub name: [::core::ffi::c_char; 16usize],
    pub mm: *mut mm_struct,
    pub thread: *mut thread_struct,
    pub list: List,
    pub addr_limit: u64,
    pub pid: ::core::ffi::c_long,
    pub priority: ::core::ffi::c_long,
    pub virtual_runtime: i64,
    pub fds: [*mut vfs_file_t; 16usize],
    pub next_pcb: *mut process_control_block,
    pub parent_pcb: *mut process_control_block,
    pub exit_code: i32,
    pub policy: u32,
    pub wait_child_proc_exit: wait_queue_node_t,
    pub worker_private: *mut ::core::ffi::c_void,
}
#[test]
fn bindgen_test_layout_process_control_block() {
    const UNINIT: ::core::mem::MaybeUninit<process_control_block> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<process_control_block>(),
        304usize,
        concat!("Size of: ", stringify!(process_control_block))
    );
    assert_eq!(
        ::core::mem::align_of::<process_control_block>(),
        8usize,
        concat!("Alignment of ", stringify!(process_control_block))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(process_control_block),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(process_control_block),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).preempt_count) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(process_control_block),
            "::",
            stringify!(preempt_count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).signal) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(process_control_block),
            "::",
            stringify!(signal)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cpu_id) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(process_control_block),
            "::",
            stringify!(cpu_id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(process_control_block),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mm) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(process_control_block),
            "::",
            stringify!(mm)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).thread) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(process_control_block),
            "::",
            stringify!(thread)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).list) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(process_control_block),
            "::",
            stringify!(list)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).addr_limit) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(process_control_block),
            "::",
            stringify!(addr_limit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pid) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(process_control_block),
            "::",
            stringify!(pid)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).priority) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(process_control_block),
            "::",
            stringify!(priority)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).virtual_runtime) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(process_control_block),
            "::",
            stringify!(virtual_runtime)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fds) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(process_control_block),
            "::",
            stringify!(fds)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).next_pcb) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(process_control_block),
            "::",
            stringify!(next_pcb)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).parent_pcb) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(process_control_block),
            "::",
            stringify!(parent_pcb)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).exit_code) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(process_control_block),
            "::",
            stringify!(exit_code)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).policy) as usize - ptr as usize },
        268usize,
        concat!(
            "Offset of field: ",
            stringify!(process_control_block),
            "::",
            stringify!(policy)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).wait_child_proc_exit) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(process_control_block),
            "::",
            stringify!(wait_child_proc_exit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).worker_private) as usize - ptr as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(process_control_block),
            "::",
            stringify!(worker_private)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union proc_union {
    pub pcb: process_control_block,
    pub stack: [ul; 4096usize],
}
#[test]
fn bindgen_test_layout_proc_union() {
    const UNINIT: ::core::mem::MaybeUninit<proc_union> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<proc_union>(),
        32768usize,
        concat!("Size of: ", stringify!(proc_union))
    );
    assert_eq!(
        ::core::mem::align_of::<proc_union>(),
        8usize,
        concat!("Alignment of ", stringify!(proc_union))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pcb) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(proc_union),
            "::",
            stringify!(pcb)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).stack) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(proc_union),
            "::",
            stringify!(stack)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct tss_struct {
    pub reserved0: ::core::ffi::c_uint,
    pub rsp0: ul,
    pub rsp1: ul,
    pub rsp2: ul,
    pub reserved1: ul,
    pub ist1: ul,
    pub ist2: ul,
    pub ist3: ul,
    pub ist4: ul,
    pub ist5: ul,
    pub ist6: ul,
    pub ist7: ul,
    pub reserved2: ul,
    pub reserved3: ::core::ffi::c_ushort,
    pub io_map_base_addr: ::core::ffi::c_ushort,
}
#[test]
fn bindgen_test_layout_tss_struct() {
    const UNINIT: ::core::mem::MaybeUninit<tss_struct> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<tss_struct>(),
        104usize,
        concat!("Size of: ", stringify!(tss_struct))
    );
    assert_eq!(
        ::core::mem::align_of::<tss_struct>(),
        1usize,
        concat!("Alignment of ", stringify!(tss_struct))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved0) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tss_struct),
            "::",
            stringify!(reserved0)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rsp0) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tss_struct),
            "::",
            stringify!(rsp0)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rsp1) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(tss_struct),
            "::",
            stringify!(rsp1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rsp2) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(tss_struct),
            "::",
            stringify!(rsp2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved1) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(tss_struct),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ist1) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(tss_struct),
            "::",
            stringify!(ist1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ist2) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(tss_struct),
            "::",
            stringify!(ist2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ist3) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(tss_struct),
            "::",
            stringify!(ist3)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ist4) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(tss_struct),
            "::",
            stringify!(ist4)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ist5) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(tss_struct),
            "::",
            stringify!(ist5)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ist6) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(tss_struct),
            "::",
            stringify!(ist6)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ist7) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(tss_struct),
            "::",
            stringify!(ist7)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved2) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(tss_struct),
            "::",
            stringify!(reserved2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved3) as usize - ptr as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(tss_struct),
            "::",
            stringify!(reserved3)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).io_map_base_addr) as usize - ptr as usize },
        102usize,
        concat!(
            "Offset of field: ",
            stringify!(tss_struct),
            "::",
            stringify!(io_map_base_addr)
        )
    );
}
extern "C" {
    pub static mut font_ascii: [[::core::ffi::c_uchar; 16usize]; 256usize];
}
#[doc = " @brief 帧缓冲区信息结构体"]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct scm_buffer_info_t {
    pub width: u32,
    pub height: u32,
    pub size: u32,
    pub bit_depth: u32,
    pub vaddr: u64,
    pub flags: u64,
}
#[test]
fn bindgen_test_layout_scm_buffer_info_t() {
    const UNINIT: ::core::mem::MaybeUninit<scm_buffer_info_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<scm_buffer_info_t>(),
        32usize,
        concat!("Size of: ", stringify!(scm_buffer_info_t))
    );
    assert_eq!(
        ::core::mem::align_of::<scm_buffer_info_t>(),
        8usize,
        concat!("Alignment of ", stringify!(scm_buffer_info_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_buffer_info_t),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_buffer_info_t),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_buffer_info_t),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit_depth) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_buffer_info_t),
            "::",
            stringify!(bit_depth)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).vaddr) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_buffer_info_t),
            "::",
            stringify!(vaddr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_buffer_info_t),
            "::",
            stringify!(flags)
        )
    );
}
#[doc = " @brief 上层ui框架应当实现的接口"]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct scm_ui_framework_operations_t {
    pub install: ::core::option::Option<
        unsafe extern "C" fn(buf: *mut scm_buffer_info_t) -> ::core::ffi::c_int,
    >,
    pub uninstall: ::core::option::Option<
        unsafe extern "C" fn(args: *mut ::core::ffi::c_void) -> ::core::ffi::c_int,
    >,
    pub enable: ::core::option::Option<
        unsafe extern "C" fn(args: *mut ::core::ffi::c_void) -> ::core::ffi::c_int,
    >,
    pub disable: ::core::option::Option<
        unsafe extern "C" fn(args: *mut ::core::ffi::c_void) -> ::core::ffi::c_int,
    >,
    pub change: ::core::option::Option<
        unsafe extern "C" fn(buf: *mut scm_buffer_info_t) -> ::core::ffi::c_int,
    >,
}
#[test]
fn bindgen_test_layout_scm_ui_framework_operations_t() {
    const UNINIT: ::core::mem::MaybeUninit<scm_ui_framework_operations_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<scm_ui_framework_operations_t>(),
        40usize,
        concat!("Size of: ", stringify!(scm_ui_framework_operations_t))
    );
    assert_eq!(
        ::core::mem::align_of::<scm_ui_framework_operations_t>(),
        8usize,
        concat!("Alignment of ", stringify!(scm_ui_framework_operations_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).install) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_ui_framework_operations_t),
            "::",
            stringify!(install)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).uninstall) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_ui_framework_operations_t),
            "::",
            stringify!(uninstall)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).enable) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_ui_framework_operations_t),
            "::",
            stringify!(enable)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).disable) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_ui_framework_operations_t),
            "::",
            stringify!(disable)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).change) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_ui_framework_operations_t),
            "::",
            stringify!(change)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct scm_ui_framework_t {
    pub list: List,
    pub id: u16,
    pub name: [::core::ffi::c_char; 16usize],
    pub type_: u8,
    pub ui_ops: *mut scm_ui_framework_operations_t,
    pub buf: *mut scm_buffer_info_t,
}
#[test]
fn bindgen_test_layout_scm_ui_framework_t() {
    const UNINIT: ::core::mem::MaybeUninit<scm_ui_framework_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<scm_ui_framework_t>(),
        56usize,
        concat!("Size of: ", stringify!(scm_ui_framework_t))
    );
    assert_eq!(
        ::core::mem::align_of::<scm_ui_framework_t>(),
        8usize,
        concat!("Alignment of ", stringify!(scm_ui_framework_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).list) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_ui_framework_t),
            "::",
            stringify!(list)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_ui_framework_t),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_ui_framework_t),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_ui_framework_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ui_ops) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_ui_framework_t),
            "::",
            stringify!(ui_ops)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).buf) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(scm_ui_framework_t),
            "::",
            stringify!(buf)
        )
    );
}
extern "C" {
    #[doc = " @brief 初始化屏幕管理模块"]
    #[doc = ""]
    pub fn scm_init();
}
extern "C" {
    #[doc = " @brief 当内存管理单元被初始化之后，重新处理帧缓冲区问题"]
    #[doc = ""]
    pub fn scm_reinit();
}
extern "C" {
    #[doc = " @brief 向屏幕管理器注册UI框架（动态获取框架对象结构体）"]
    #[doc = ""]
    #[doc = " @param name 框架名"]
    #[doc = " @param type 类型"]
    #[doc = " @param ops 框架操作方法"]
    #[doc = " @return int"]
    pub fn scm_register_alloc(
        name: *const ::core::ffi::c_char,
        type_: u8,
        ops: *mut scm_ui_framework_operations_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief 向屏幕管理器注册UI框架（静态设置的框架对象）"]
    #[doc = ""]
    #[doc = " @param ui 框架结构体指针"]
    #[doc = " @return int 错误码"]
    pub fn scm_register(ui: *mut scm_ui_framework_t) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief 向屏幕管理器卸载UI框架"]
    #[doc = ""]
    #[doc = " @param ui ui框架结构体"]
    #[doc = " @return int"]
    pub fn scm_unregister(ui: *mut scm_ui_framework_t) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief 向屏幕管理器卸载动态创建的UI框架"]
    #[doc = ""]
    #[doc = " @param ui ui框架结构体"]
    #[doc = " @return int"]
    pub fn scm_unregister_alloc(ui: *mut scm_ui_framework_t) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief 允许动态申请内存"]
    #[doc = ""]
    #[doc = " @return int"]
    pub fn scm_enable_alloc() -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief 允许双缓冲区"]
    #[doc = ""]
    #[doc = " @return int"]
    pub fn scm_enable_double_buffer() -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief 启用某个ui框架，将它的帧缓冲区渲染到屏幕上"]
    #[doc = ""]
    #[doc = " @param ui 要启动的ui框架"]
    #[doc = " @return int 返回码"]
    pub fn scm_framework_enable(ui: *mut scm_ui_framework_t) -> ::core::ffi::c_int;
}
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
extern "C" {
    #[doc = " @brief 将字符串按照fmt和args中的内容进行格式化，然后保存到buf中"]
    #[doc = ""]
    #[doc = " @param buf 结果缓冲区"]
    #[doc = " @param fmt 格式化字符串"]
    #[doc = " @param args 内容"]
    #[doc = " @return 最终字符串的长度"]
    pub fn vsprintf(
        buf: *mut ::core::ffi::c_char,
        fmt: *const ::core::ffi::c_char,
        args: *mut __va_list_tag,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief 将字符串按照fmt和args中的内容进行格式化，截取字符串前buf_size-1，保存到buf中"]
    #[doc = ""]
    #[doc = " @param buf 结果缓冲区，大小为buf_size"]
    #[doc = " @param fmt 格式化字符串"]
    #[doc = " @param buf_size 缓冲区长度"]
    #[doc = " @param args 内容"]
    #[doc = " @return 最终字符串的长度"]
    pub fn vsnprintf(
        buf: *mut ::core::ffi::c_char,
        fmt: *const ::core::ffi::c_char,
        buf_size: ::core::ffi::c_int,
        args: *mut __va_list_tag,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn printk_color(
        FRcolor: ::core::ffi::c_uint,
        BKcolor: ::core::ffi::c_uint,
        fmt: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief 格式化字符串并输出到buf"]
    #[doc = ""]
    #[doc = " @param buf 输出缓冲区"]
    #[doc = " @param fmt 格式"]
    #[doc = " @param ... 参数"]
    #[doc = " @return int 字符串长度"]
    pub fn sprintk(
        buf: *mut ::core::ffi::c_char,
        fmt: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
#[doc = " @brief 定义自旋锁结构体"]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spinlock_t {
    pub lock: i8,
}
#[test]
fn bindgen_test_layout_spinlock_t() {
    const UNINIT: ::core::mem::MaybeUninit<spinlock_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<spinlock_t>(),
        1usize,
        concat!("Size of: ", stringify!(spinlock_t))
    );
    assert_eq!(
        ::core::mem::align_of::<spinlock_t>(),
        1usize,
        concat!("Alignment of ", stringify!(spinlock_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).lock) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spinlock_t),
            "::",
            stringify!(lock)
        )
    );
}
extern "C" {
    #[doc = " @brief 自旋锁加锁"]
    #[doc = ""]
    #[doc = " @param lock"]
    pub fn spin_lock(lock: *mut spinlock_t);
}
extern "C" {
    #[doc = " @brief 自旋锁解锁"]
    #[doc = ""]
    #[doc = " @param lock"]
    pub fn spin_unlock(lock: *mut spinlock_t);
}
extern "C" {
    #[doc = " @brief 初始化自旋锁"]
    #[doc = ""]
    #[doc = " @param lock"]
    pub fn spin_init(lock: *mut spinlock_t);
}
extern "C" {
    #[doc = " @brief 自旋锁加锁（不改变自旋锁持有计数）"]
    #[doc = ""]
    #[doc = " @warning 慎用此函数，除非你有十足的把握不会产生自旋锁计数错误"]
    pub fn spin_lock_no_preempt(lock: *mut spinlock_t);
}
extern "C" {
    #[doc = " @brief 自旋锁解锁（不改变自旋锁持有计数）"]
    #[doc = ""]
    #[doc = " @warning 慎用此函数，除非你有十足的把握不会产生自旋锁计数错误"]
    pub fn spin_unlock_no_preempt(lock: *mut spinlock_t);
}
extern "C" {
    #[doc = " @brief 尝试加锁"]
    #[doc = ""]
    #[doc = " @param lock"]
    #[doc = " @return long 锁变量的值（1为成功加锁，0为加锁失败）"]
    pub fn spin_trylock(lock: *mut spinlock_t) -> ::core::ffi::c_long;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kfifo_t {
    pub total_size: u32,
    pub size: u32,
    pub in_offset: u32,
    pub out_offset: u32,
    pub buffer: *mut ::core::ffi::c_void,
}
#[test]
fn bindgen_test_layout_kfifo_t() {
    const UNINIT: ::core::mem::MaybeUninit<kfifo_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<kfifo_t>(),
        24usize,
        concat!("Size of: ", stringify!(kfifo_t))
    );
    assert_eq!(
        ::core::mem::align_of::<kfifo_t>(),
        8usize,
        concat!("Alignment of ", stringify!(kfifo_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).total_size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kfifo_t),
            "::",
            stringify!(total_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(kfifo_t),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).in_offset) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(kfifo_t),
            "::",
            stringify!(in_offset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).out_offset) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(kfifo_t),
            "::",
            stringify!(out_offset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(kfifo_t),
            "::",
            stringify!(buffer)
        )
    );
}
extern "C" {
    #[doc = " @brief 通过动态方式初始化kfifo缓冲队列"]
    #[doc = ""]
    #[doc = " @param fifo 队列结构体"]
    #[doc = " @param size 缓冲区大小"]
    #[doc = " @param reserved 暂时保留，请置为0"]
    #[doc = " @return int 错误码：成功->0"]
    pub fn kfifo_alloc(fifo: *mut kfifo_t, size: u32, reserved: u64) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief 释放通过kfifo_alloc创建的fifo缓冲区"]
    #[doc = ""]
    #[doc = " @param fifo fifo队列结构体"]
    pub fn kfifo_free_alloc(fifo: *mut kfifo_t);
}
extern "C" {
    #[doc = " @brief 使用指定的缓冲区来初始化kfifo缓冲队列"]
    #[doc = ""]
    #[doc = " @param fifo 队列结构体"]
    #[doc = " @param buffer 缓冲区"]
    #[doc = " @param size 缓冲区大小"]
    pub fn kfifo_init(fifo: *mut kfifo_t, buffer: *mut ::core::ffi::c_void, size: u32);
}
extern "C" {
    #[doc = " @brief 向kfifo缓冲区推入指定大小的数据"]
    #[doc = ""]
    #[doc = " @param fifo 队列结构体"]
    #[doc = " @param from 来源数据地址"]
    #[doc = " @param size 数据大小（字节数）"]
    #[doc = " @return uint32_t 推入的数据大小"]
    pub fn kfifo_in(fifo: *mut kfifo_t, from: *const ::core::ffi::c_void, size: u32) -> u32;
}
extern "C" {
    #[doc = " @brief 从kfifo缓冲区取出数据，并从队列中删除数据"]
    #[doc = ""]
    #[doc = " @param fifo 队列结构体"]
    #[doc = " @param to 拷贝目标地址"]
    #[doc = " @param size 数据大小（字节数）"]
    #[doc = " @return uint32_t 取出的数据大小"]
    pub fn kfifo_out(fifo: *mut kfifo_t, to: *mut ::core::ffi::c_void, size: u32) -> u32;
}
extern "C" {
    #[doc = " @brief 从kfifo缓冲区取出数据，但是不从队列中删除数据"]
    #[doc = ""]
    #[doc = " @param fifo 队列结构体"]
    #[doc = " @param to 拷贝目标地址"]
    #[doc = " @param size 数据大小（字节数）"]
    #[doc = " @return uint32_t 取出的数据大小"]
    pub fn kfifo_out_peek(fifo: *mut kfifo_t, to: *mut ::core::ffi::c_void, size: u32) -> u32;
}
extern "C" {
    pub fn LZ4_versionNumber() -> ::core::ffi::c_int;
}
extern "C" {
    pub fn LZ4_versionString() -> *const ::core::ffi::c_char;
}
extern "C" {
    #[doc = " LZ4_compress_default() :"]
    #[doc = "  Compresses 'srcSize' bytes from buffer 'src'"]
    #[doc = "  into already allocated 'dst' buffer of size 'dstCapacity'."]
    #[doc = "  Compression is guaranteed to succeed if 'dstCapacity' >= LZ4_compressBound(srcSize)."]
    #[doc = "  It also runs faster, so it's a recommended setting."]
    #[doc = "  If the function cannot compress 'src' into a more limited 'dst' budget,"]
    #[doc = "  compression stops *immediately*, and the function result is zero."]
    #[doc = "  In which case, 'dst' content is undefined (invalid)."]
    #[doc = "      srcSize : max supported value is LZ4_MAX_INPUT_SIZE."]
    #[doc = "      dstCapacity : size of buffer 'dst' (which must be already allocated)"]
    #[doc = "     @return  : the number of bytes written into buffer 'dst' (necessarily <= dstCapacity)"]
    #[doc = "                or 0 if compression fails"]
    #[doc = " Note : This function is protected against buffer overflow scenarios (never writes outside 'dst' buffer, nor read outside 'source' buffer)."]
    pub fn LZ4_compress_default(
        src: *const ::core::ffi::c_char,
        dst: *mut ::core::ffi::c_char,
        srcSize: ::core::ffi::c_int,
        dstCapacity: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " LZ4_decompress_safe() :"]
    #[doc = "  compressedSize : is the exact complete size of the compressed block."]
    #[doc = "  dstCapacity : is the size of destination buffer (which must be already allocated), presumed an upper bound of decompressed size."]
    #[doc = " @return : the number of bytes decompressed into destination buffer (necessarily <= dstCapacity)"]
    #[doc = "           If destination buffer is not large enough, decoding will stop and output an error code (negative value)."]
    #[doc = "           If the source stream is detected malformed, the function will stop decoding and return a negative result."]
    #[doc = " Note 1 : This function is protected against malicious data packets :"]
    #[doc = "          it will never writes outside 'dst' buffer, nor read outside 'source' buffer,"]
    #[doc = "          even if the compressed block is maliciously modified to order the decoder to do these actions."]
    #[doc = "          In such case, the decoder stops immediately, and considers the compressed block malformed."]
    #[doc = " Note 2 : compressedSize and dstCapacity must be provided to the function, the compressed block does not contain them."]
    #[doc = "          The implementation is free to send / store / derive this information in whichever way is most beneficial."]
    #[doc = "          If there is a need for a different format which bundles together both compressed data and its metadata, consider looking at lz4frame.h instead."]
    pub fn LZ4_decompress_safe(
        src: *const ::core::ffi::c_char,
        dst: *mut ::core::ffi::c_char,
        compressedSize: ::core::ffi::c_int,
        dstCapacity: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " LZ4_compressBound() :"]
    #[doc = "Provides the maximum size that LZ4 compression may output in a \"worst case\" scenario (input data not compressible)"]
    #[doc = "This function is primarily useful for memory allocation purposes (destination buffer size)."]
    #[doc = "Macro LZ4_COMPRESSBOUND() is also provided for compilation-time evaluation (stack memory allocation for example)."]
    #[doc = "Note that LZ4_compress_default() compresses faster when dstCapacity is >= LZ4_compressBound(srcSize)"]
    #[doc = "inputSize  : max supported value is LZ4_MAX_INPUT_SIZE"]
    #[doc = "return : maximum output size in a \"worst case\" scenario"]
    #[doc = "or 0, if input size is incorrect (too large or negative)"]
    pub fn LZ4_compressBound(inputSize: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " LZ4_compress_fast() :"]
    #[doc = "Same as LZ4_compress_default(), but allows selection of \"acceleration\" factor."]
    #[doc = "The larger the acceleration value, the faster the algorithm, but also the lesser the compression."]
    #[doc = "It's a trade-off. It can be fine tuned, with each successive value providing roughly +~3% to speed."]
    #[doc = "An acceleration value of \"1\" is the same as regular LZ4_compress_default()"]
    #[doc = "Values <= 0 will be replaced by LZ4_ACCELERATION_DEFAULT (currently == 1, see lz4.c)."]
    #[doc = "Values > LZ4_ACCELERATION_MAX will be replaced by LZ4_ACCELERATION_MAX (currently == 65537, see lz4.c)."]
    pub fn LZ4_compress_fast(
        src: *const ::core::ffi::c_char,
        dst: *mut ::core::ffi::c_char,
        srcSize: ::core::ffi::c_int,
        dstCapacity: ::core::ffi::c_int,
        acceleration: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " LZ4_compress_fast_extState() :"]
    #[doc = "  Same as LZ4_compress_fast(), using an externally allocated memory space for its state."]
    #[doc = "  Use LZ4_sizeofState() to know how much memory must be allocated,"]
    #[doc = "  and allocate it on 8-bytes boundaries (using `malloc()` typically)."]
    #[doc = "  Then, provide this buffer as `void* state` to compression function."]
    pub fn LZ4_sizeofState() -> ::core::ffi::c_int;
}
extern "C" {
    pub fn LZ4_compress_fast_extState(
        state: *mut ::core::ffi::c_void,
        src: *const ::core::ffi::c_char,
        dst: *mut ::core::ffi::c_char,
        srcSize: ::core::ffi::c_int,
        dstCapacity: ::core::ffi::c_int,
        acceleration: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " LZ4_compress_destSize() :"]
    #[doc = "  Reverse the logic : compresses as much data as possible from 'src' buffer"]
    #[doc = "  into already allocated buffer 'dst', of size >= 'targetDestSize'."]
    #[doc = "  This function either compresses the entire 'src' content into 'dst' if it's large enough,"]
    #[doc = "  or fill 'dst' buffer completely with as much data as possible from 'src'."]
    #[doc = "  note: acceleration parameter is fixed to \"default\"."]
    #[doc = ""]
    #[doc = " *srcSizePtr : will be modified to indicate how many bytes where read from 'src' to fill 'dst'."]
    #[doc = "               New value is necessarily <= input value."]
    #[doc = " @return : Nb bytes written into 'dst' (necessarily <= targetDestSize)"]
    #[doc = "           or 0 if compression fails."]
    #[doc = ""]
    #[doc = " Note : from v1.8.2 to v1.9.1, this function had a bug (fixed un v1.9.2+):"]
    #[doc = "        the produced compressed content could, in specific circumstances,"]
    #[doc = "        require to be decompressed into a destination buffer larger"]
    #[doc = "        by at least 1 byte than the content to decompress."]
    #[doc = "        If an application uses `LZ4_compress_destSize()`,"]
    #[doc = "        it's highly recommended to update liblz4 to v1.9.2 or better."]
    #[doc = "        If this can't be done or ensured,"]
    #[doc = "        the receiving decompression function should provide"]
    #[doc = "        a dstCapacity which is > decompressedSize, by at least 1 byte."]
    #[doc = "        See https://github.com/lz4/lz4/issues/859 for details"]
    pub fn LZ4_compress_destSize(
        src: *const ::core::ffi::c_char,
        dst: *mut ::core::ffi::c_char,
        srcSizePtr: *mut ::core::ffi::c_int,
        targetDstSize: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " LZ4_decompress_safe_partial() :"]
    #[doc = "  Decompress an LZ4 compressed block, of size 'srcSize' at position 'src',"]
    #[doc = "  into destination buffer 'dst' of size 'dstCapacity'."]
    #[doc = "  Up to 'targetOutputSize' bytes will be decoded."]
    #[doc = "  The function stops decoding on reaching this objective."]
    #[doc = "  This can be useful to boost performance"]
    #[doc = "  whenever only the beginning of a block is required."]
    #[doc = ""]
    #[doc = " @return : the number of bytes decoded in `dst` (necessarily <= targetOutputSize)"]
    #[doc = "           If source stream is detected malformed, function returns a negative result."]
    #[doc = ""]
    #[doc = "  Note 1 : @return can be < targetOutputSize, if compressed block contains less data."]
    #[doc = ""]
    #[doc = "  Note 2 : targetOutputSize must be <= dstCapacity"]
    #[doc = ""]
    #[doc = "  Note 3 : this function effectively stops decoding on reaching targetOutputSize,"]
    #[doc = "           so dstCapacity is kind of redundant."]
    #[doc = "           This is because in older versions of this function,"]
    #[doc = "           decoding operation would still write complete sequences."]
    #[doc = "           Therefore, there was no guarantee that it would stop writing at exactly targetOutputSize,"]
    #[doc = "           it could write more bytes, though only up to dstCapacity."]
    #[doc = "           Some \"margin\" used to be required for this operation to work properly."]
    #[doc = "           Thankfully, this is no longer necessary."]
    #[doc = "           The function nonetheless keeps the same signature, in an effort to preserve API compatibility."]
    #[doc = ""]
    #[doc = "  Note 4 : If srcSize is the exact size of the block,"]
    #[doc = "           then targetOutputSize can be any value,"]
    #[doc = "           including larger than the block's decompressed size."]
    #[doc = "           The function will, at most, generate block's decompressed size."]
    #[doc = ""]
    #[doc = "  Note 5 : If srcSize is _larger_ than block's compressed size,"]
    #[doc = "           then targetOutputSize **MUST** be <= block's decompressed size."]
    #[doc = "           Otherwise, *silent corruption will occur*."]
    pub fn LZ4_decompress_safe_partial(
        src: *const ::core::ffi::c_char,
        dst: *mut ::core::ffi::c_char,
        srcSize: ::core::ffi::c_int,
        targetOutputSize: ::core::ffi::c_int,
        dstCapacity: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
pub type LZ4_stream_t = LZ4_stream_u;
extern "C" {
    pub fn LZ4_createStream() -> *mut LZ4_stream_t;
}
extern "C" {
    pub fn LZ4_freeStream(streamPtr: *mut LZ4_stream_t) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " LZ4_resetStream_fast() : v1.9.0+"]
    #[doc = "  Use this to prepare an LZ4_stream_t for a new chain of dependent blocks"]
    #[doc = "  (e.g., LZ4_compress_fast_continue())."]
    #[doc = ""]
    #[doc = "  An LZ4_stream_t must be initialized once before usage."]
    #[doc = "  This is automatically done when created by LZ4_createStream()."]
    #[doc = "  However, should the LZ4_stream_t be simply declared on stack (for example),"]
    #[doc = "  it's necessary to initialize it first, using LZ4_initStream()."]
    #[doc = ""]
    #[doc = "  After init, start any new stream with LZ4_resetStream_fast()."]
    #[doc = "  A same LZ4_stream_t can be re-used multiple times consecutively"]
    #[doc = "  and compress multiple streams,"]
    #[doc = "  provided that it starts each new stream with LZ4_resetStream_fast()."]
    #[doc = ""]
    #[doc = "  LZ4_resetStream_fast() is much faster than LZ4_initStream(),"]
    #[doc = "  but is not compatible with memory regions containing garbage data."]
    #[doc = ""]
    #[doc = "  Note: it's only useful to call LZ4_resetStream_fast()"]
    #[doc = "        in the context of streaming compression."]
    #[doc = "        The *extState* functions perform their own resets."]
    #[doc = "        Invoking LZ4_resetStream_fast() before is redundant, and even counterproductive."]
    pub fn LZ4_resetStream_fast(streamPtr: *mut LZ4_stream_t);
}
extern "C" {
    #[doc = " LZ4_loadDict() :"]
    #[doc = "  Use this function to reference a static dictionary into LZ4_stream_t."]
    #[doc = "  The dictionary must remain available during compression."]
    #[doc = "  LZ4_loadDict() triggers a reset, so any previous data will be forgotten."]
    #[doc = "  The same dictionary will have to be loaded on decompression side for successful decoding."]
    #[doc = "  Dictionary are useful for better compression of small data (KB range)."]
    #[doc = "  While LZ4 accept any input as dictionary,"]
    #[doc = "  results are generally better when using Zstandard's Dictionary Builder."]
    #[doc = "  Loading a size of 0 is allowed, and is the same as reset."]
    #[doc = " @return : loaded dictionary size, in bytes (necessarily <= 64 KB)"]
    pub fn LZ4_loadDict(
        streamPtr: *mut LZ4_stream_t,
        dictionary: *const ::core::ffi::c_char,
        dictSize: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " LZ4_compress_fast_continue() :"]
    #[doc = "  Compress 'src' content using data from previously compressed blocks, for better compression ratio."]
    #[doc = " 'dst' buffer must be already allocated."]
    #[doc = "  If dstCapacity >= LZ4_compressBound(srcSize), compression is guaranteed to succeed, and runs faster."]
    #[doc = ""]
    #[doc = " @return : size of compressed block"]
    #[doc = "           or 0 if there is an error (typically, cannot fit into 'dst')."]
    #[doc = ""]
    #[doc = "  Note 1 : Each invocation to LZ4_compress_fast_continue() generates a new block."]
    #[doc = "           Each block has precise boundaries."]
    #[doc = "           Each block must be decompressed separately, calling LZ4_decompress_*() with relevant metadata."]
    #[doc = "           It's not possible to append blocks together and expect a single invocation of LZ4_decompress_*() to decompress them together."]
    #[doc = ""]
    #[doc = "  Note 2 : The previous 64KB of source data is __assumed__ to remain present, unmodified, at same address in memory !"]
    #[doc = ""]
    #[doc = "  Note 3 : When input is structured as a double-buffer, each buffer can have any size, including < 64 KB."]
    #[doc = "           Make sure that buffers are separated, by at least one byte."]
    #[doc = "           This construction ensures that each block only depends on previous block."]
    #[doc = ""]
    #[doc = "  Note 4 : If input buffer is a ring-buffer, it can have any size, including < 64 KB."]
    #[doc = ""]
    #[doc = "  Note 5 : After an error, the stream status is undefined (invalid), it can only be reset or freed."]
    pub fn LZ4_compress_fast_continue(
        streamPtr: *mut LZ4_stream_t,
        src: *const ::core::ffi::c_char,
        dst: *mut ::core::ffi::c_char,
        srcSize: ::core::ffi::c_int,
        dstCapacity: ::core::ffi::c_int,
        acceleration: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " LZ4_saveDict() :"]
    #[doc = "  If last 64KB data cannot be guaranteed to remain available at its current memory location,"]
    #[doc = "  save it into a safer place (char* safeBuffer)."]
    #[doc = "  This is schematically equivalent to a memcpy() followed by LZ4_loadDict(),"]
    #[doc = "  but is much faster, because LZ4_saveDict() doesn't need to rebuild tables."]
    #[doc = " @return : saved dictionary size in bytes (necessarily <= maxDictSize), or 0 if error."]
    pub fn LZ4_saveDict(
        streamPtr: *mut LZ4_stream_t,
        safeBuffer: *mut ::core::ffi::c_char,
        maxDictSize: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
pub type LZ4_streamDecode_t = LZ4_streamDecode_u;
extern "C" {
    #[doc = " LZ4_createStreamDecode() and LZ4_freeStreamDecode() :"]
    #[doc = "  creation / destruction of streaming decompression tracking context."]
    #[doc = "  A tracking context can be re-used multiple times."]
    pub fn LZ4_createStreamDecode() -> *mut LZ4_streamDecode_t;
}
extern "C" {
    pub fn LZ4_freeStreamDecode(LZ4_stream: *mut LZ4_streamDecode_t) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " LZ4_setStreamDecode() :"]
    #[doc = "  An LZ4_streamDecode_t context can be allocated once and re-used multiple times."]
    #[doc = "  Use this function to start decompression of a new stream of blocks."]
    #[doc = "  A dictionary can optionally be set. Use NULL or size 0 for a reset order."]
    #[doc = "  Dictionary is presumed stable : it must remain accessible and unmodified during next decompression."]
    #[doc = " @return : 1 if OK, 0 if error"]
    pub fn LZ4_setStreamDecode(
        LZ4_streamDecode: *mut LZ4_streamDecode_t,
        dictionary: *const ::core::ffi::c_char,
        dictSize: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " LZ4_decoderRingBufferSize() : v1.8.2+"]
    #[doc = "  Note : in a ring buffer scenario (optional),"]
    #[doc = "  blocks are presumed decompressed next to each other"]
    #[doc = "  up to the moment there is not enough remaining space for next block (remainingSize < maxBlockSize),"]
    #[doc = "  at which stage it resumes from beginning of ring buffer."]
    #[doc = "  When setting such a ring buffer for streaming decompression,"]
    #[doc = "  provides the minimum size of this ring buffer"]
    #[doc = "  to be compatible with any source respecting maxBlockSize condition."]
    #[doc = " @return : minimum ring buffer size,"]
    #[doc = "           or 0 if there is an error (invalid maxBlockSize)."]
    pub fn LZ4_decoderRingBufferSize(maxBlockSize: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " LZ4_decompress_*_continue() :"]
    #[doc = "  These decoding functions allow decompression of consecutive blocks in \"streaming\" mode."]
    #[doc = "  A block is an unsplittable entity, it must be presented entirely to a decompression function."]
    #[doc = "  Decompression functions only accepts one block at a time."]
    #[doc = "  The last 64KB of previously decoded data *must* remain available and unmodified at the memory position where they were decoded."]
    #[doc = "  If less than 64KB of data has been decoded, all the data must be present."]
    #[doc = ""]
    #[doc = "  Special : if decompression side sets a ring buffer, it must respect one of the following conditions :"]
    #[doc = "  - Decompression buffer size is _at least_ LZ4_decoderRingBufferSize(maxBlockSize)."]
    #[doc = "    maxBlockSize is the maximum size of any single block. It can have any value > 16 bytes."]
    #[doc = "    In which case, encoding and decoding buffers do not need to be synchronized."]
    #[doc = "    Actually, data can be produced by any source compliant with LZ4 format specification, and respecting maxBlockSize."]
    #[doc = "  - Synchronized mode :"]
    #[doc = "    Decompression buffer size is _exactly_ the same as compression buffer size,"]
    #[doc = "    and follows exactly same update rule (block boundaries at same positions),"]
    #[doc = "    and decoding function is provided with exact decompressed size of each block (exception for last block of the stream),"]
    #[doc = "    _then_ decoding & encoding ring buffer can have any size, including small ones ( < 64 KB)."]
    #[doc = "  - Decompression buffer is larger than encoding buffer, by a minimum of maxBlockSize more bytes."]
    #[doc = "    In which case, encoding and decoding buffers do not need to be synchronized,"]
    #[doc = "    and encoding ring buffer can have any size, including small ones ( < 64 KB)."]
    #[doc = ""]
    #[doc = "  Whenever these conditions are not possible,"]
    #[doc = "  save the last 64KB of decoded data into a safe buffer where it can't be modified during decompression,"]
    #[doc = "  then indicate where this data is saved using LZ4_setStreamDecode(), before decompressing next block."]
    pub fn LZ4_decompress_safe_continue(
        LZ4_streamDecode: *mut LZ4_streamDecode_t,
        src: *const ::core::ffi::c_char,
        dst: *mut ::core::ffi::c_char,
        srcSize: ::core::ffi::c_int,
        dstCapacity: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " LZ4_decompress_*_usingDict() :"]
    #[doc = "  These decoding functions work the same as"]
    #[doc = "  a combination of LZ4_setStreamDecode() followed by LZ4_decompress_*_continue()"]
    #[doc = "  They are stand-alone, and don't need an LZ4_streamDecode_t structure."]
    #[doc = "  Dictionary is presumed stable : it must remain accessible and unmodified during decompression."]
    #[doc = "  Performance tip : Decompression speed can be substantially increased"]
    #[doc = "                    when dst == dictStart + dictSize."]
    pub fn LZ4_decompress_safe_usingDict(
        src: *const ::core::ffi::c_char,
        dst: *mut ::core::ffi::c_char,
        srcSize: ::core::ffi::c_int,
        dstCapcity: ::core::ffi::c_int,
        dictStart: *const ::core::ffi::c_char,
        dictSize: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
pub type LZ4_i8 = i8;
pub type LZ4_byte = u8;
pub type LZ4_u16 = u16;
pub type LZ4_u32 = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LZ4_stream_t_internal {
    pub hashTable: [LZ4_u32; 4096usize],
    pub currentOffset: LZ4_u32,
    pub tableType: LZ4_u32,
    pub dictionary: *const LZ4_byte,
    pub dictCtx: *const LZ4_stream_t_internal,
    pub dictSize: LZ4_u32,
}
#[test]
fn bindgen_test_layout_LZ4_stream_t_internal() {
    const UNINIT: ::core::mem::MaybeUninit<LZ4_stream_t_internal> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<LZ4_stream_t_internal>(),
        16416usize,
        concat!("Size of: ", stringify!(LZ4_stream_t_internal))
    );
    assert_eq!(
        ::core::mem::align_of::<LZ4_stream_t_internal>(),
        8usize,
        concat!("Alignment of ", stringify!(LZ4_stream_t_internal))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hashTable) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4_stream_t_internal),
            "::",
            stringify!(hashTable)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).currentOffset) as usize - ptr as usize },
        16384usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4_stream_t_internal),
            "::",
            stringify!(currentOffset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tableType) as usize - ptr as usize },
        16388usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4_stream_t_internal),
            "::",
            stringify!(tableType)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dictionary) as usize - ptr as usize },
        16392usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4_stream_t_internal),
            "::",
            stringify!(dictionary)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dictCtx) as usize - ptr as usize },
        16400usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4_stream_t_internal),
            "::",
            stringify!(dictCtx)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dictSize) as usize - ptr as usize },
        16408usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4_stream_t_internal),
            "::",
            stringify!(dictSize)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LZ4_streamDecode_t_internal {
    pub externalDict: *const LZ4_byte,
    pub extDictSize: usize,
    pub prefixEnd: *const LZ4_byte,
    pub prefixSize: usize,
}
#[test]
fn bindgen_test_layout_LZ4_streamDecode_t_internal() {
    const UNINIT: ::core::mem::MaybeUninit<LZ4_streamDecode_t_internal> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<LZ4_streamDecode_t_internal>(),
        32usize,
        concat!("Size of: ", stringify!(LZ4_streamDecode_t_internal))
    );
    assert_eq!(
        ::core::mem::align_of::<LZ4_streamDecode_t_internal>(),
        8usize,
        concat!("Alignment of ", stringify!(LZ4_streamDecode_t_internal))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).externalDict) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4_streamDecode_t_internal),
            "::",
            stringify!(externalDict)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).extDictSize) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4_streamDecode_t_internal),
            "::",
            stringify!(extDictSize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).prefixEnd) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4_streamDecode_t_internal),
            "::",
            stringify!(prefixEnd)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).prefixSize) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4_streamDecode_t_internal),
            "::",
            stringify!(prefixSize)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union LZ4_stream_u {
    pub table: [*mut ::core::ffi::c_void; 2052usize],
    pub internal_donotuse: LZ4_stream_t_internal,
}
#[test]
fn bindgen_test_layout_LZ4_stream_u() {
    const UNINIT: ::core::mem::MaybeUninit<LZ4_stream_u> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<LZ4_stream_u>(),
        16416usize,
        concat!("Size of: ", stringify!(LZ4_stream_u))
    );
    assert_eq!(
        ::core::mem::align_of::<LZ4_stream_u>(),
        8usize,
        concat!("Alignment of ", stringify!(LZ4_stream_u))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).table) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4_stream_u),
            "::",
            stringify!(table)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).internal_donotuse) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4_stream_u),
            "::",
            stringify!(internal_donotuse)
        )
    );
}
extern "C" {
    #[doc = " LZ4_initStream() : v1.9.0+"]
    #[doc = "  An LZ4_stream_t structure must be initialized at least once."]
    #[doc = "  This is automatically done when invoking LZ4_createStream(),"]
    #[doc = "  but it's not when the structure is simply declared on stack (for example)."]
    #[doc = ""]
    #[doc = "  Use LZ4_initStream() to properly initialize a newly declared LZ4_stream_t."]
    #[doc = "  It can also initialize any arbitrary buffer of sufficient size,"]
    #[doc = "  and will @return a pointer of proper type upon initialization."]
    #[doc = ""]
    #[doc = "  Note : initialization fails if size and alignment conditions are not respected."]
    #[doc = "         In which case, the function will @return NULL."]
    #[doc = "  Note2: An LZ4_stream_t structure guarantees correct alignment and size."]
    #[doc = "  Note3: Before v1.9.0, use LZ4_resetStream() instead"]
    pub fn LZ4_initStream(buffer: *mut ::core::ffi::c_void, size: usize) -> *mut LZ4_stream_t;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union LZ4_streamDecode_u {
    pub table: [::core::ffi::c_ulonglong; 4usize],
    pub internal_donotuse: LZ4_streamDecode_t_internal,
}
#[test]
fn bindgen_test_layout_LZ4_streamDecode_u() {
    const UNINIT: ::core::mem::MaybeUninit<LZ4_streamDecode_u> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<LZ4_streamDecode_u>(),
        32usize,
        concat!("Size of: ", stringify!(LZ4_streamDecode_u))
    );
    assert_eq!(
        ::core::mem::align_of::<LZ4_streamDecode_u>(),
        8usize,
        concat!("Alignment of ", stringify!(LZ4_streamDecode_u))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).table) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4_streamDecode_u),
            "::",
            stringify!(table)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).internal_donotuse) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4_streamDecode_u),
            "::",
            stringify!(internal_donotuse)
        )
    );
}
extern "C" {
    #[doc = " Obsolete compression functions (since v1.7.3)"]
    pub fn LZ4_compress(
        src: *const ::core::ffi::c_char,
        dest: *mut ::core::ffi::c_char,
        srcSize: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn LZ4_compress_limitedOutput(
        src: *const ::core::ffi::c_char,
        dest: *mut ::core::ffi::c_char,
        srcSize: ::core::ffi::c_int,
        maxOutputSize: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn LZ4_compress_withState(
        state: *mut ::core::ffi::c_void,
        source: *const ::core::ffi::c_char,
        dest: *mut ::core::ffi::c_char,
        inputSize: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn LZ4_compress_limitedOutput_withState(
        state: *mut ::core::ffi::c_void,
        source: *const ::core::ffi::c_char,
        dest: *mut ::core::ffi::c_char,
        inputSize: ::core::ffi::c_int,
        maxOutputSize: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn LZ4_compress_continue(
        LZ4_streamPtr: *mut LZ4_stream_t,
        source: *const ::core::ffi::c_char,
        dest: *mut ::core::ffi::c_char,
        inputSize: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn LZ4_compress_limitedOutput_continue(
        LZ4_streamPtr: *mut LZ4_stream_t,
        source: *const ::core::ffi::c_char,
        dest: *mut ::core::ffi::c_char,
        inputSize: ::core::ffi::c_int,
        maxOutputSize: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " Obsolete decompression functions (since v1.8.0)"]
    pub fn LZ4_uncompress(
        source: *const ::core::ffi::c_char,
        dest: *mut ::core::ffi::c_char,
        outputSize: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn LZ4_uncompress_unknownOutputSize(
        source: *const ::core::ffi::c_char,
        dest: *mut ::core::ffi::c_char,
        isize_: ::core::ffi::c_int,
        maxOutputSize: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn LZ4_create(inputBuffer: *mut ::core::ffi::c_char) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn LZ4_sizeofStreamState() -> ::core::ffi::c_int;
}
extern "C" {
    pub fn LZ4_resetStreamState(
        state: *mut ::core::ffi::c_void,
        inputBuffer: *mut ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn LZ4_slideInputBuffer(state: *mut ::core::ffi::c_void) -> *mut ::core::ffi::c_char;
}
extern "C" {
    #[doc = " Obsolete streaming decoding functions (since v1.7.0)"]
    pub fn LZ4_decompress_safe_withPrefix64k(
        src: *const ::core::ffi::c_char,
        dst: *mut ::core::ffi::c_char,
        compressedSize: ::core::ffi::c_int,
        maxDstSize: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn LZ4_decompress_fast_withPrefix64k(
        src: *const ::core::ffi::c_char,
        dst: *mut ::core::ffi::c_char,
        originalSize: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " Obsolete LZ4_decompress_fast variants (since v1.9.0) :"]
    #[doc = "  These functions used to be faster than LZ4_decompress_safe(),"]
    #[doc = "  but this is no longer the case. They are now slower."]
    #[doc = "  This is because LZ4_decompress_fast() doesn't know the input size,"]
    #[doc = "  and therefore must progress more cautiously into the input buffer to not read beyond the end of block."]
    #[doc = "  On top of that `LZ4_decompress_fast()` is not protected vs malformed or malicious inputs, making it a security liability."]
    #[doc = "  As a consequence, LZ4_decompress_fast() is strongly discouraged, and deprecated."]
    #[doc = ""]
    #[doc = "  The last remaining LZ4_decompress_fast() specificity is that"]
    #[doc = "  it can decompress a block without knowing its compressed size."]
    #[doc = "  Such functionality can be achieved in a more secure manner"]
    #[doc = "  by employing LZ4_decompress_safe_partial()."]
    #[doc = ""]
    #[doc = "  Parameters:"]
    #[doc = "  originalSize : is the uncompressed size to regenerate."]
    #[doc = "                 `dst` must be already allocated, its size must be >= 'originalSize' bytes."]
    #[doc = " @return : number of bytes read from source buffer (== compressed size)."]
    #[doc = "           The function expects to finish at block's end exactly."]
    #[doc = "           If the source stream is detected malformed, the function stops decoding and returns a negative result."]
    #[doc = "  note : LZ4_decompress_fast*() requires originalSize. Thanks to this information, it never writes past the output buffer."]
    #[doc = "         However, since it doesn't know its 'src' size, it may read an unknown amount of input, past input buffer bounds."]
    #[doc = "         Also, since match offsets are not validated, match reads from 'src' may underflow too."]
    #[doc = "         These issues never happen if input (compressed) data is correct."]
    #[doc = "         But they may happen if input data is invalid (error or intentional tampering)."]
    #[doc = "         As a consequence, use these functions in trusted environments with trusted data **only**."]
    pub fn LZ4_decompress_fast(
        src: *const ::core::ffi::c_char,
        dst: *mut ::core::ffi::c_char,
        originalSize: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn LZ4_decompress_fast_continue(
        LZ4_streamDecode: *mut LZ4_streamDecode_t,
        src: *const ::core::ffi::c_char,
        dst: *mut ::core::ffi::c_char,
        originalSize: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn LZ4_decompress_fast_usingDict(
        src: *const ::core::ffi::c_char,
        dst: *mut ::core::ffi::c_char,
        originalSize: ::core::ffi::c_int,
        dictStart: *const ::core::ffi::c_char,
        dictSize: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " LZ4_resetStream() :"]
    #[doc = "  An LZ4_stream_t structure must be initialized at least once."]
    #[doc = "  This is done with LZ4_initStream(), or LZ4_resetStream()."]
    #[doc = "  Consider switching to LZ4_initStream(),"]
    #[doc = "  invoking LZ4_resetStream() will trigger deprecation warnings in the future."]
    pub fn LZ4_resetStream(streamPtr: *mut LZ4_stream_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pt_regs {
    pub r15: ::core::ffi::c_ulong,
    pub r14: ::core::ffi::c_ulong,
    pub r13: ::core::ffi::c_ulong,
    pub r12: ::core::ffi::c_ulong,
    pub r11: ::core::ffi::c_ulong,
    pub r10: ::core::ffi::c_ulong,
    pub r9: ::core::ffi::c_ulong,
    pub r8: ::core::ffi::c_ulong,
    pub rbx: ::core::ffi::c_ulong,
    pub rcx: ::core::ffi::c_ulong,
    pub rdx: ::core::ffi::c_ulong,
    pub rsi: ::core::ffi::c_ulong,
    pub rdi: ::core::ffi::c_ulong,
    pub rbp: ::core::ffi::c_ulong,
    pub ds: ::core::ffi::c_ulong,
    pub es: ::core::ffi::c_ulong,
    pub rax: ::core::ffi::c_ulong,
    pub func: ::core::ffi::c_ulong,
    pub errcode: ::core::ffi::c_ulong,
    pub rip: ::core::ffi::c_ulong,
    pub cs: ::core::ffi::c_ulong,
    pub rflags: ::core::ffi::c_ulong,
    pub rsp: ::core::ffi::c_ulong,
    pub ss: ::core::ffi::c_ulong,
}
#[test]
fn bindgen_test_layout_pt_regs() {
    const UNINIT: ::core::mem::MaybeUninit<pt_regs> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<pt_regs>(),
        192usize,
        concat!("Size of: ", stringify!(pt_regs))
    );
    assert_eq!(
        ::core::mem::align_of::<pt_regs>(),
        8usize,
        concat!("Alignment of ", stringify!(pt_regs))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).r15) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(r15)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).r14) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(r14)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).r13) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(r13)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).r12) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(r12)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).r11) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(r11)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).r10) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(r10)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).r9) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(r9)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).r8) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(r8)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rbx) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(rbx)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rcx) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(rcx)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rdx) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(rdx)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rsi) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(rsi)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rdi) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(rdi)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rbp) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(rbp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ds) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(ds)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).es) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(es)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rax) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(rax)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).func) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(func)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).errcode) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(errcode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rip) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(rip)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cs) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(cs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rflags) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(rflags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rsp) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(rsp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ss) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(ss)
        )
    );
}
pub type system_call_t =
    ::core::option::Option<unsafe extern "C" fn(regs: *mut pt_regs) -> ::core::ffi::c_ulong>;
extern "C" {
    pub fn ret_from_system_call();
}
extern "C" {
    pub static mut system_call_table: [system_call_t; 256usize];
}
extern "C" {
    #[doc = " @brief 初始化系统调用模块"]
    #[doc = ""]
    pub fn syscall_init();
}
extern "C" {
    #[doc = " @brief 用户态系统调用入口函数"]
    #[doc = " 从用户态进入系统调用"]
    #[doc = " @param syscall_id 系统调用id"]
    #[doc = " @return long 错误码"]
    pub fn enter_syscall(
        syscall_id: ul,
        arg0: ul,
        arg1: ul,
        arg2: ul,
        arg3: ul,
        arg4: ul,
        arg5: ul,
        arg6: ul,
        arg7: ul,
    ) -> ::core::ffi::c_long;
}
extern "C" {
    pub fn enter_syscall_int(
        syscall_id: ul,
        arg0: ul,
        arg1: ul,
        arg2: ul,
        arg3: ul,
        arg4: ul,
        arg5: ul,
        arg6: ul,
        arg7: ul,
    ) -> ::core::ffi::c_long;
}
extern "C" {
    #[doc = " @brief 系统调用不存在时的处理函数"]
    #[doc = ""]
    #[doc = " @param regs 进程3特权级下的寄存器"]
    #[doc = " @return ul"]
    pub fn system_call_not_exists(regs: *mut pt_regs) -> ul;
}
extern "C" {
    #[doc = " @brief 打印字符串的系统调用"]
    #[doc = ""]
    #[doc = " 当arg1和arg2均为0时，打印黑底白字，否则按照指定的前景色和背景色来打印"]
    #[doc = ""]
    #[doc = " @param regs 寄存器"]
    #[doc = " @param arg0 要打印的字符串"]
    #[doc = " @param arg1 前景色"]
    #[doc = " @param arg2 背景色"]
    #[doc = " @return ul 返回值"]
    pub fn sys_printf(regs: *mut pt_regs) -> ul;
}
extern "C" {
    #[doc = " @brief 将堆内存调整为arg0"]
    #[doc = ""]
    #[doc = " @param arg0 新的堆区域的结束地址"]
    #[doc = " arg0=0  ===> 返回堆区域的起始地址"]
    #[doc = " arg0=-1  ===> 返回堆区域的结束地址"]
    #[doc = " @return uint64_t 错误码"]
    #[doc = ""]
    pub fn sys_brk(regs: *mut pt_regs) -> u64;
}
extern "C" {
    #[doc = " @brief 将堆内存空间加上offset（注意，该系统调用只应在普通进程中调用，而不能是内核线程）"]
    #[doc = ""]
    #[doc = " @param arg0 offset偏移量"]
    #[doc = " @return uint64_t the previous program break"]
    pub fn sys_sbrk(regs: *mut pt_regs) -> u64;
}
extern "C" {
    #[doc = " @brief 创建文件夹"]
    #[doc = " 在VFS.c中实现"]
    #[doc = " @param path(r8) 路径"]
    #[doc = " @param mode(r9) 模式"]
    #[doc = " @return uint64_t"]
    pub fn sys_mkdir(regs: *mut pt_regs) -> u64;
}
extern "C" {
    #[doc = " @brief 创建管道"]
    #[doc = " 在pipe.c中实现"]
    #[doc = " @param fd(r8) 文件句柄指针"]
    #[doc = " @param num(r9) 文件句柄个数"]
    #[doc = " @return uint64_t"]
    pub fn sys_pipe(regs: *mut pt_regs) -> u64;
}
extern "C" {
    pub fn sys_ahci_end_req(regs: *mut pt_regs) -> ul;
}
extern "C" {
    pub fn do_syscall_int(regs: *mut pt_regs, error_code: ::core::ffi::c_ulong);
}
extern "C" {
    #[doc = " @brief fork当前进程"]
    #[doc = ""]
    #[doc = " @return pid_t"]
    pub fn fork() -> u64;
}
extern "C" {
    #[doc = " @brief vfork当前进程"]
    #[doc = ""]
    #[doc = " @return pid_t"]
    pub fn vfork() -> u64;
}
extern "C" {
    #[doc = " @brief  交换n字节"]
    #[doc = "  @param src  源地址"]
    #[doc = "  @param dest  目的地址"]
    #[doc = " @param nbytes  交换字节数"]
    pub fn swab(src: *mut ::core::ffi::c_void, dest: *mut ::core::ffi::c_void, nbytes: isize);
}
extern "C" {
    pub static mut Cpu_cpuid_max_Basic_mop: u32;
}
extern "C" {
    pub static mut Cpu_cpuid_max_Extended_mop: u32;
}
extern "C" {
    pub static mut Cpu_Manufacturer_Name: [::core::ffi::c_char; 17usize];
}
extern "C" {
    pub static mut Cpu_BrandName: [::core::ffi::c_char; 49usize];
}
extern "C" {
    pub static mut Cpu_Family_ID: u32;
}
extern "C" {
    pub static mut Cpu_Extended_Family_ID: u32;
}
extern "C" {
    pub static mut Cpu_Model_ID: u32;
}
extern "C" {
    pub static mut Cpu_Extended_Model_ID: u32;
}
extern "C" {
    pub static mut Cpu_Stepping_ID: u32;
}
extern "C" {
    pub static mut Cpu_Processor_Type: u32;
}
extern "C" {
    pub static mut Cpu_max_phys_addrline_size: u32;
}
extern "C" {
    pub static mut Cpu_max_linear_addrline_size: u32;
}
extern "C" {
    pub static mut Cpu_tsc_freq: u64;
}
extern "C" {
    #[doc = " @brief 执行cpuid指令"]
    #[doc = ""]
    #[doc = " @param mop 主功能号"]
    #[doc = " @param sop 子功能号"]
    #[doc = " @param eax 结果的eax值"]
    #[doc = " @param ebx 结果的ebx值"]
    #[doc = " @param ecx 结果的ecx值"]
    #[doc = " @param edx 结果的edx值"]
    #[doc = ""]
    #[doc = " cpuid指令参考英特尔开发手册卷2A Chapter3 3.2 Instruction"]
    pub fn cpu_cpuid(
        mop: u32,
        sop: u32,
        eax: *mut u32,
        ebx: *mut u32,
        ecx: *mut u32,
        edx: *mut u32,
    );
}
extern "C" {
    #[doc = " @brief 初始化获取处理器信息模块"]
    #[doc = ""]
    pub fn cpu_init();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cpu_core_info_t {
    pub stack_start: u64,
    pub ist_stack_start: u64,
    pub tss_vaddr: u64,
}
#[test]
fn bindgen_test_layout_cpu_core_info_t() {
    const UNINIT: ::core::mem::MaybeUninit<cpu_core_info_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<cpu_core_info_t>(),
        24usize,
        concat!("Size of: ", stringify!(cpu_core_info_t))
    );
    assert_eq!(
        ::core::mem::align_of::<cpu_core_info_t>(),
        8usize,
        concat!("Alignment of ", stringify!(cpu_core_info_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).stack_start) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_core_info_t),
            "::",
            stringify!(stack_start)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ist_stack_start) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_core_info_t),
            "::",
            stringify!(ist_stack_start)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tss_vaddr) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_core_info_t),
            "::",
            stringify!(tss_vaddr)
        )
    );
}
extern "C" {
    pub static mut cpu_core_info: [cpu_core_info_t; 32usize];
}
extern "C" {
    #[doc = " @brief 获取当前cpu核心晶振频率"]
    #[doc = ""]
    #[doc = " @return uint32_t 当前cpu核心晶振频率"]
    pub fn cpu_get_core_crysral_freq() -> u32;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct atomic_t {
    pub value: ::core::ffi::c_long,
}
#[test]
fn bindgen_test_layout_atomic_t() {
    const UNINIT: ::core::mem::MaybeUninit<atomic_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<atomic_t>(),
        8usize,
        concat!("Size of: ", stringify!(atomic_t))
    );
    assert_eq!(
        ::core::mem::align_of::<atomic_t>(),
        8usize,
        concat!("Alignment of ", stringify!(atomic_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(atomic_t),
            "::",
            stringify!(value)
        )
    );
}
extern "C" {
    #[doc = " @brief 原子变量自增"]
    #[doc = ""]
    #[doc = " @param ato 原子变量对象"]
    pub fn atomic_inc(ato: *mut atomic_t);
}
extern "C" {
    #[doc = " @brief 原子变量自减"]
    #[doc = ""]
    #[doc = " @param ato 原子变量对象"]
    pub fn atomic_dec(ato: *mut atomic_t);
}
#[doc = " @brief 信号量的结构体"]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct semaphore_t {
    pub counter: atomic_t,
    pub wait_queue: wait_queue_node_t,
}
#[test]
fn bindgen_test_layout_semaphore_t() {
    const UNINIT: ::core::mem::MaybeUninit<semaphore_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<semaphore_t>(),
        32usize,
        concat!("Size of: ", stringify!(semaphore_t))
    );
    assert_eq!(
        ::core::mem::align_of::<semaphore_t>(),
        8usize,
        concat!("Alignment of ", stringify!(semaphore_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).counter) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(semaphore_t),
            "::",
            stringify!(counter)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).wait_queue) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(semaphore_t),
            "::",
            stringify!(wait_queue)
        )
    );
}
extern "C" {
    #[doc = " @brief 信号量down"]
    #[doc = ""]
    #[doc = " @param sema"]
    pub fn semaphore_down(sema: *mut semaphore_t);
}
extern "C" {
    pub fn semaphore_up(sema: *mut semaphore_t);
}
#[doc = " @brief Mutex - 互斥锁"]
#[doc = ""]
#[doc = " - 同一时间只有1个任务可以持有mutex"]
#[doc = " - 不允许递归地加锁、解锁"]
#[doc = " - 只允许通过mutex的api来操作mutex"]
#[doc = " - 在硬中断、软中断中不能使用mutex"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mutex_t {
    pub count: atomic_t,
    pub wait_lock: spinlock_t,
    pub wait_list: List,
}
#[test]
fn bindgen_test_layout_mutex_t() {
    const UNINIT: ::core::mem::MaybeUninit<mutex_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<mutex_t>(),
        32usize,
        concat!("Size of: ", stringify!(mutex_t))
    );
    assert_eq!(
        ::core::mem::align_of::<mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(mutex_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mutex_t),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).wait_lock) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mutex_t),
            "::",
            stringify!(wait_lock)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).wait_list) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(mutex_t),
            "::",
            stringify!(wait_list)
        )
    );
}
#[doc = " @brief 在mutex上的等待者的结构体"]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mutex_waiter_t {
    pub list: List,
    pub pcb: *mut process_control_block,
}
#[test]
fn bindgen_test_layout_mutex_waiter_t() {
    const UNINIT: ::core::mem::MaybeUninit<mutex_waiter_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<mutex_waiter_t>(),
        24usize,
        concat!("Size of: ", stringify!(mutex_waiter_t))
    );
    assert_eq!(
        ::core::mem::align_of::<mutex_waiter_t>(),
        8usize,
        concat!("Alignment of ", stringify!(mutex_waiter_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).list) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mutex_waiter_t),
            "::",
            stringify!(list)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pcb) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(mutex_waiter_t),
            "::",
            stringify!(pcb)
        )
    );
}
extern "C" {
    #[doc = " @brief 初始化互斥量"]
    #[doc = ""]
    #[doc = " @param lock mutex结构体"]
    pub fn mutex_init(lock: *mut mutex_t);
}
extern "C" {
    #[doc = " @brief 对互斥量加锁"]
    #[doc = ""]
    #[doc = " @param lock mutex结构体"]
    pub fn mutex_lock(lock: *mut mutex_t);
}
extern "C" {
    #[doc = " @brief 对互斥量解锁"]
    #[doc = ""]
    #[doc = " @param lock mutex结构体"]
    pub fn mutex_unlock(lock: *mut mutex_t);
}
extern "C" {
    #[doc = " @brief 尝试对互斥量加锁"]
    #[doc = ""]
    #[doc = " @param lock mutex结构体"]
    #[doc = ""]
    #[doc = " @return 成功加锁->1, 加锁失败->0"]
    pub fn mutex_trylock(lock: *mut mutex_t) -> ::core::ffi::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct block_device_operation {
    pub open: ::core::option::Option<unsafe extern "C" fn() -> ::core::ffi::c_long>,
    pub close: ::core::option::Option<unsafe extern "C" fn() -> ::core::ffi::c_long>,
    pub ioctl: ::core::option::Option<
        unsafe extern "C" fn(
            cmd: ::core::ffi::c_long,
            arg: ::core::ffi::c_long,
        ) -> ::core::ffi::c_long,
    >,
    #[doc = " @brief 块设备驱动程序的传输函数"]
    #[doc = ""]
    #[doc = " @param gd 磁盘设备结构体"]
    #[doc = " @param cmd 控制命令"]
    #[doc = " @param base_addr 48位LBA地址"]
    #[doc = " @param count total sectors to read"]
    #[doc = " @param buf 缓冲区线性地址"]
    #[doc = " @return long"]
    pub transfer: ::core::option::Option<
        unsafe extern "C" fn(
            gd: *mut blk_gendisk,
            cmd: ::core::ffi::c_long,
            base_addr: u64,
            count: u64,
            buf: u64,
        ) -> ::core::ffi::c_long,
    >,
}
#[test]
fn bindgen_test_layout_block_device_operation() {
    const UNINIT: ::core::mem::MaybeUninit<block_device_operation> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<block_device_operation>(),
        32usize,
        concat!("Size of: ", stringify!(block_device_operation))
    );
    assert_eq!(
        ::core::mem::align_of::<block_device_operation>(),
        8usize,
        concat!("Alignment of ", stringify!(block_device_operation))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).open) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(block_device_operation),
            "::",
            stringify!(open)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).close) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(block_device_operation),
            "::",
            stringify!(close)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ioctl) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(block_device_operation),
            "::",
            stringify!(ioctl)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).transfer) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(block_device_operation),
            "::",
            stringify!(transfer)
        )
    );
}
#[doc = " @brief 块设备请求队列内的packet"]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct block_device_request_packet {
    pub cmd: uchar,
    pub LBA_start: u64,
    pub count: u32,
    pub buffer_vaddr: u64,
    pub device_type: u8,
    pub end_handler: ::core::option::Option<unsafe extern "C" fn(num: ul, arg: ul)>,
    pub wait_queue: wait_queue_node_t,
}
#[test]
fn bindgen_test_layout_block_device_request_packet() {
    const UNINIT: ::core::mem::MaybeUninit<block_device_request_packet> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<block_device_request_packet>(),
        72usize,
        concat!("Size of: ", stringify!(block_device_request_packet))
    );
    assert_eq!(
        ::core::mem::align_of::<block_device_request_packet>(),
        8usize,
        concat!("Alignment of ", stringify!(block_device_request_packet))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cmd) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(block_device_request_packet),
            "::",
            stringify!(cmd)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).LBA_start) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(block_device_request_packet),
            "::",
            stringify!(LBA_start)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(block_device_request_packet),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).buffer_vaddr) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(block_device_request_packet),
            "::",
            stringify!(buffer_vaddr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).device_type) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(block_device_request_packet),
            "::",
            stringify!(device_type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).end_handler) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(block_device_request_packet),
            "::",
            stringify!(end_handler)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).wait_queue) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(block_device_request_packet),
            "::",
            stringify!(wait_queue)
        )
    );
}
#[doc = " @brief 块设备的请求队列"]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct block_device_request_queue {
    pub wait_queue_list: wait_queue_node_t,
    pub in_service: *mut block_device_request_packet,
    pub request_count: ul,
}
#[test]
fn bindgen_test_layout_block_device_request_queue() {
    const UNINIT: ::core::mem::MaybeUninit<block_device_request_queue> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<block_device_request_queue>(),
        40usize,
        concat!("Size of: ", stringify!(block_device_request_queue))
    );
    assert_eq!(
        ::core::mem::align_of::<block_device_request_queue>(),
        8usize,
        concat!("Alignment of ", stringify!(block_device_request_queue))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).wait_queue_list) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(block_device_request_queue),
            "::",
            stringify!(wait_queue_list)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).in_service) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(block_device_request_queue),
            "::",
            stringify!(in_service)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).request_count) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(block_device_request_queue),
            "::",
            stringify!(request_count)
        )
    );
}
#[doc = " @brief 块设备结构体（对应磁盘的一个分区）"]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct block_device {
    pub bd_start_sector: sector_t,
    pub bd_start_LBA: u64,
    pub bd_sectors_num: sector_t,
    pub bd_superblock: *mut vfs_superblock_t,
    pub bd_disk: *mut blk_gendisk,
    pub bd_queue: *mut block_device_request_queue,
    pub bd_partno: u16,
}
#[test]
fn bindgen_test_layout_block_device() {
    const UNINIT: ::core::mem::MaybeUninit<block_device> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<block_device>(),
        56usize,
        concat!("Size of: ", stringify!(block_device))
    );
    assert_eq!(
        ::core::mem::align_of::<block_device>(),
        8usize,
        concat!("Alignment of ", stringify!(block_device))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bd_start_sector) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(block_device),
            "::",
            stringify!(bd_start_sector)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bd_start_LBA) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(block_device),
            "::",
            stringify!(bd_start_LBA)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bd_sectors_num) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(block_device),
            "::",
            stringify!(bd_sectors_num)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bd_superblock) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(block_device),
            "::",
            stringify!(bd_superblock)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bd_disk) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(block_device),
            "::",
            stringify!(bd_disk)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bd_queue) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(block_device),
            "::",
            stringify!(bd_queue)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bd_partno) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(block_device),
            "::",
            stringify!(bd_partno)
        )
    );
}
#[doc = " @brief 磁盘设备结构体"]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct blk_gendisk {
    pub disk_name: [::core::ffi::c_char; 32usize],
    pub part_cnt: u16,
    pub flags: u16,
    pub partition: *mut block_device,
    pub fops: *const block_device_operation,
    pub request_queue: *mut block_device_request_queue,
    pub private_data: *mut ::core::ffi::c_void,
    pub open_mutex: mutex_t,
}
#[test]
fn bindgen_test_layout_blk_gendisk() {
    const UNINIT: ::core::mem::MaybeUninit<blk_gendisk> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<blk_gendisk>(),
        104usize,
        concat!("Size of: ", stringify!(blk_gendisk))
    );
    assert_eq!(
        ::core::mem::align_of::<blk_gendisk>(),
        8usize,
        concat!("Alignment of ", stringify!(blk_gendisk))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).disk_name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(blk_gendisk),
            "::",
            stringify!(disk_name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).part_cnt) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(blk_gendisk),
            "::",
            stringify!(part_cnt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(blk_gendisk),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).partition) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(blk_gendisk),
            "::",
            stringify!(partition)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fops) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(blk_gendisk),
            "::",
            stringify!(fops)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).request_queue) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(blk_gendisk),
            "::",
            stringify!(request_queue)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).private_data) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(blk_gendisk),
            "::",
            stringify!(private_data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).open_mutex) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(blk_gendisk),
            "::",
            stringify!(open_mutex)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lockref {
    pub __bindgen_anon_1: lockref__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union lockref__bindgen_ty_1 {
    pub lock_count: u64,
    pub __bindgen_anon_1: lockref__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lockref__bindgen_ty_1__bindgen_ty_1 {
    pub lock: spinlock_t,
    pub count: ::core::ffi::c_int,
}
#[test]
fn bindgen_test_layout_lockref__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<lockref__bindgen_ty_1__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lockref__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(lockref__bindgen_ty_1__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<lockref__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(lockref__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).lock) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lockref__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lockref__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(count)
        )
    );
}
#[test]
fn bindgen_test_layout_lockref__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<lockref__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lockref__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(lockref__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<lockref__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(lockref__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).lock_count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lockref__bindgen_ty_1),
            "::",
            stringify!(lock_count)
        )
    );
}
#[test]
fn bindgen_test_layout_lockref() {
    assert_eq!(
        ::core::mem::size_of::<lockref>(),
        8usize,
        concat!("Size of: ", stringify!(lockref))
    );
    assert_eq!(
        ::core::mem::align_of::<lockref>(),
        8usize,
        concat!("Alignment of ", stringify!(lockref))
    );
}
extern "C" {
    #[doc = " @brief 原子的将引用计数加1"]
    #[doc = ""]
    #[doc = " @param lock_ref 要被操作的lockref变量"]
    pub fn lockref_inc(lock_ref: *mut lockref);
}
extern "C" {
    #[doc = " @brief 原子地将引用计数加1.如果原来的count≤0，则操作失败。"]
    #[doc = ""]
    #[doc = " @param lock_ref 指向要被操作的lockref变量的指针"]
    #[doc = " @return int  操作成功=>true"]
    #[doc = "              操作失败=>false"]
    pub fn lockref_inc_not_zero(lock_ref: *mut lockref) -> bool;
}
extern "C" {
    #[doc = " @brief 原子地减少引用计数。如果已处于count≤0的状态，则返回-1"]
    #[doc = ""]
    #[doc = " 本函数与lockref_dec_return()的区别在于，当在cmpxchg()中检测到count<=0或已加锁，本函数会再次尝试通过加锁来执行操作"]
    #[doc = " 而后者会直接返回错误"]
    #[doc = ""]
    #[doc = " @param lock_ref 指向要被操作的lockref变量的指针"]
    #[doc = " @return int 操作成功 => 返回新的引用变量值"]
    #[doc = "             lockref处于count≤0的状态 => 返回-1"]
    pub fn lockref_dec(lock_ref: *mut lockref) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief 原子地减少引用计数。如果处于已加锁或count≤0的状态，则返回-1"]
    #[doc = ""]
    #[doc = " 本函数与lockref_dec()的区别在于，当在cmpxchg()中检测到count<=0或已加锁，本函数会直接返回错误"]
    #[doc = " 而后者会再次尝试通过加锁来执行操作"]
    #[doc = ""]
    #[doc = " @param lock_ref 指向要被操作的lockref变量的指针"]
    #[doc = " @return int  操作成功 => 返回新的引用变量值"]
    #[doc = "              lockref处于已加锁或count≤0的状态 => 返回-1"]
    pub fn lockref_dec_return(lock_ref: *mut lockref) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief 原子地减少引用计数。若当前的引用计数≤1，则操作失败"]
    #[doc = ""]
    #[doc = " 该函数与lockref_dec_or_lock_not_zero()的区别在于，当cmpxchg()时发现old.count≤1时，该函数会直接返回false."]
    #[doc = " 而后者在这种情况下，会尝试加锁来进行操作。"]
    #[doc = ""]
    #[doc = " @param lock_ref 指向要被操作的lockref变量的指针"]
    #[doc = " @return true 成功将引用计数减1"]
    #[doc = " @return false 如果当前的引用计数≤1，操作失败"]
    pub fn lockref_dec_not_zero(lock_ref: *mut lockref) -> bool;
}
extern "C" {
    #[doc = " @brief 原子地减少引用计数。若当前的引用计数≤1，则操作失败"]
    #[doc = ""]
    #[doc = " 该函数与lockref_dec_not_zero()的区别在于，当cmpxchg()时发现old.count≤1时，该函数会尝试加锁来进行操作。"]
    #[doc = " 而后者在这种情况下，会直接返回false."]
    #[doc = ""]
    #[doc = " @param lock_ref 指向要被操作的lockref变量的指针"]
    #[doc = " @return true 成功将引用计数减1"]
    #[doc = " @return false 如果当前的引用计数≤1，操作失败"]
    pub fn lockref_dec_or_lock_not_zero(lock_ref: *mut lockref) -> bool;
}
extern "C" {
    #[doc = " @brief 将lockref变量标记为已经死亡（将count设置为负值）"]
    #[doc = ""]
    #[doc = " @param lock_ref 指向要被操作的lockref变量的指针"]
    pub fn lockref_mark_dead(lock_ref: *mut lockref);
}
extern "C" {
    #[doc = " @brief 自增引用计数。（除非该lockref已经死亡）"]
    #[doc = ""]
    #[doc = " @param lock_ref 指向要被操作的lockref变量的指针"]
    #[doc = " @return true 操作成功"]
    #[doc = " @return false 操作失败，lockref已死亡"]
    pub fn lockref_inc_not_dead(lock_ref: *mut lockref) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct user_namespace {}
#[test]
fn bindgen_test_layout_user_namespace() {
    assert_eq!(
        ::core::mem::size_of::<user_namespace>(),
        0usize,
        concat!("Size of: ", stringify!(user_namespace))
    );
    assert_eq!(
        ::core::mem::align_of::<user_namespace>(),
        1usize,
        concat!("Alignment of ", stringify!(user_namespace))
    );
}
pub type vm_flags_t = u64;
#[doc = " @brief 内存页表结构体"]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pml4t_t {
    pub pml4t: ::core::ffi::c_ulong,
}
#[test]
fn bindgen_test_layout_pml4t_t() {
    const UNINIT: ::core::mem::MaybeUninit<pml4t_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<pml4t_t>(),
        8usize,
        concat!("Size of: ", stringify!(pml4t_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pml4t_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pml4t_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pml4t) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pml4t_t),
            "::",
            stringify!(pml4t)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pdpt_t {
    pub pdpt: ::core::ffi::c_ulong,
}
#[test]
fn bindgen_test_layout_pdpt_t() {
    const UNINIT: ::core::mem::MaybeUninit<pdpt_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<pdpt_t>(),
        8usize,
        concat!("Size of: ", stringify!(pdpt_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pdpt_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pdpt_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pdpt) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pdpt_t),
            "::",
            stringify!(pdpt)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pdt_t {
    pub pdt: ::core::ffi::c_ulong,
}
#[test]
fn bindgen_test_layout_pdt_t() {
    const UNINIT: ::core::mem::MaybeUninit<pdt_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<pdt_t>(),
        8usize,
        concat!("Size of: ", stringify!(pdt_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pdt_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pdt_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pdt) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pdt_t),
            "::",
            stringify!(pdt)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pt_t {
    pub pt: ::core::ffi::c_ulong,
}
#[test]
fn bindgen_test_layout_pt_t() {
    const UNINIT: ::core::mem::MaybeUninit<pt_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<pt_t>(),
        8usize,
        concat!("Size of: ", stringify!(pt_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pt_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pt_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pt) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(pt_t), "::", stringify!(pt))
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ARDS {
    pub BaseAddr: ul,
    pub Length: ul,
    pub type_: ::core::ffi::c_uint,
}
#[test]
fn bindgen_test_layout_ARDS() {
    const UNINIT: ::core::mem::MaybeUninit<ARDS> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ARDS>(),
        20usize,
        concat!("Size of: ", stringify!(ARDS))
    );
    assert_eq!(
        ::core::mem::align_of::<ARDS>(),
        1usize,
        concat!("Alignment of ", stringify!(ARDS))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BaseAddr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ARDS),
            "::",
            stringify!(BaseAddr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Length) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ARDS),
            "::",
            stringify!(Length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ARDS),
            "::",
            stringify!(type_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct memory_desc {
    pub e820: [ARDS; 32usize],
    pub len_e820: ul,
    pub bmp: *mut ul,
    pub bmp_len: ul,
    pub bits_size: ul,
    pub pages_struct: *mut Page,
    pub count_pages: ul,
    pub pages_struct_len: ul,
    pub zones_struct: *mut Zone,
    pub count_zones: ul,
    pub zones_struct_len: ul,
    pub kernel_code_start: ul,
    pub kernel_code_end: ul,
    pub kernel_data_end: ul,
    pub rodata_end: ul,
    pub start_brk: u64,
    pub end_of_struct: ul,
}
#[test]
fn bindgen_test_layout_memory_desc() {
    const UNINIT: ::core::mem::MaybeUninit<memory_desc> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<memory_desc>(),
        768usize,
        concat!("Size of: ", stringify!(memory_desc))
    );
    assert_eq!(
        ::core::mem::align_of::<memory_desc>(),
        8usize,
        concat!("Alignment of ", stringify!(memory_desc))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).e820) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(memory_desc),
            "::",
            stringify!(e820)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).len_e820) as usize - ptr as usize },
        640usize,
        concat!(
            "Offset of field: ",
            stringify!(memory_desc),
            "::",
            stringify!(len_e820)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bmp) as usize - ptr as usize },
        648usize,
        concat!(
            "Offset of field: ",
            stringify!(memory_desc),
            "::",
            stringify!(bmp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bmp_len) as usize - ptr as usize },
        656usize,
        concat!(
            "Offset of field: ",
            stringify!(memory_desc),
            "::",
            stringify!(bmp_len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bits_size) as usize - ptr as usize },
        664usize,
        concat!(
            "Offset of field: ",
            stringify!(memory_desc),
            "::",
            stringify!(bits_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pages_struct) as usize - ptr as usize },
        672usize,
        concat!(
            "Offset of field: ",
            stringify!(memory_desc),
            "::",
            stringify!(pages_struct)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).count_pages) as usize - ptr as usize },
        680usize,
        concat!(
            "Offset of field: ",
            stringify!(memory_desc),
            "::",
            stringify!(count_pages)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pages_struct_len) as usize - ptr as usize },
        688usize,
        concat!(
            "Offset of field: ",
            stringify!(memory_desc),
            "::",
            stringify!(pages_struct_len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).zones_struct) as usize - ptr as usize },
        696usize,
        concat!(
            "Offset of field: ",
            stringify!(memory_desc),
            "::",
            stringify!(zones_struct)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).count_zones) as usize - ptr as usize },
        704usize,
        concat!(
            "Offset of field: ",
            stringify!(memory_desc),
            "::",
            stringify!(count_zones)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).zones_struct_len) as usize - ptr as usize },
        712usize,
        concat!(
            "Offset of field: ",
            stringify!(memory_desc),
            "::",
            stringify!(zones_struct_len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).kernel_code_start) as usize - ptr as usize },
        720usize,
        concat!(
            "Offset of field: ",
            stringify!(memory_desc),
            "::",
            stringify!(kernel_code_start)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).kernel_code_end) as usize - ptr as usize },
        728usize,
        concat!(
            "Offset of field: ",
            stringify!(memory_desc),
            "::",
            stringify!(kernel_code_end)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).kernel_data_end) as usize - ptr as usize },
        736usize,
        concat!(
            "Offset of field: ",
            stringify!(memory_desc),
            "::",
            stringify!(kernel_data_end)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rodata_end) as usize - ptr as usize },
        744usize,
        concat!(
            "Offset of field: ",
            stringify!(memory_desc),
            "::",
            stringify!(rodata_end)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).start_brk) as usize - ptr as usize },
        752usize,
        concat!(
            "Offset of field: ",
            stringify!(memory_desc),
            "::",
            stringify!(start_brk)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).end_of_struct) as usize - ptr as usize },
        760usize,
        concat!(
            "Offset of field: ",
            stringify!(memory_desc),
            "::",
            stringify!(end_of_struct)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Zone {
    pub pages_group: *mut Page,
    pub count_pages: ul,
    pub zone_addr_start: ul,
    pub zone_addr_end: ul,
    pub zone_length: ul,
    pub attr: ul,
    pub gmd_struct: *mut memory_desc,
    pub count_pages_using: ul,
    pub count_pages_free: ul,
    pub total_pages_link: ul,
}
#[test]
fn bindgen_test_layout_Zone() {
    const UNINIT: ::core::mem::MaybeUninit<Zone> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<Zone>(),
        80usize,
        concat!("Size of: ", stringify!(Zone))
    );
    assert_eq!(
        ::core::mem::align_of::<Zone>(),
        8usize,
        concat!("Alignment of ", stringify!(Zone))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pages_group) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Zone),
            "::",
            stringify!(pages_group)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).count_pages) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Zone),
            "::",
            stringify!(count_pages)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).zone_addr_start) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Zone),
            "::",
            stringify!(zone_addr_start)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).zone_addr_end) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Zone),
            "::",
            stringify!(zone_addr_end)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).zone_length) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(Zone),
            "::",
            stringify!(zone_length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).attr) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(Zone),
            "::",
            stringify!(attr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).gmd_struct) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(Zone),
            "::",
            stringify!(gmd_struct)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).count_pages_using) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(Zone),
            "::",
            stringify!(count_pages_using)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).count_pages_free) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(Zone),
            "::",
            stringify!(count_pages_free)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).total_pages_link) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(Zone),
            "::",
            stringify!(total_pages_link)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Page {
    pub zone: *mut Zone,
    pub addr_phys: ul,
    pub attr: ul,
    pub ref_counts: ul,
    pub age: ul,
    pub anon_vma: *mut anon_vma_t,
    pub op_lock: spinlock_t,
}
#[test]
fn bindgen_test_layout_Page() {
    const UNINIT: ::core::mem::MaybeUninit<Page> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<Page>(),
        56usize,
        concat!("Size of: ", stringify!(Page))
    );
    assert_eq!(
        ::core::mem::align_of::<Page>(),
        8usize,
        concat!("Alignment of ", stringify!(Page))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).zone) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Page),
            "::",
            stringify!(zone)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).addr_phys) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Page),
            "::",
            stringify!(addr_phys)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).attr) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Page),
            "::",
            stringify!(attr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ref_counts) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Page),
            "::",
            stringify!(ref_counts)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).age) as usize - ptr as usize },
        32usize,
        concat!("Offset of field: ", stringify!(Page), "::", stringify!(age))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).anon_vma) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(Page),
            "::",
            stringify!(anon_vma)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).op_lock) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(Page),
            "::",
            stringify!(op_lock)
        )
    );
}
#[doc = " @brief 虚拟内存区域(VMA)结构体"]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vm_area_struct {
    pub vm_prev: *mut vm_area_struct,
    pub vm_next: *mut vm_area_struct,
    pub vm_start: u64,
    pub vm_end: u64,
    pub vm_mm: *mut mm_struct,
    pub vm_flags: vm_flags_t,
    pub anon_vma_list: List,
    pub anon_vma: *mut anon_vma_t,
    pub vm_ops: *mut vm_operations_t,
    pub ref_count: atomic_t,
    pub page_offset: ::core::ffi::c_ulong,
    pub private_data: *mut ::core::ffi::c_void,
}
#[test]
fn bindgen_test_layout_vm_area_struct() {
    const UNINIT: ::core::mem::MaybeUninit<vm_area_struct> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<vm_area_struct>(),
        104usize,
        concat!("Size of: ", stringify!(vm_area_struct))
    );
    assert_eq!(
        ::core::mem::align_of::<vm_area_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(vm_area_struct))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).vm_prev) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_area_struct),
            "::",
            stringify!(vm_prev)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).vm_next) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_area_struct),
            "::",
            stringify!(vm_next)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).vm_start) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_area_struct),
            "::",
            stringify!(vm_start)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).vm_end) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_area_struct),
            "::",
            stringify!(vm_end)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).vm_mm) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_area_struct),
            "::",
            stringify!(vm_mm)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).vm_flags) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_area_struct),
            "::",
            stringify!(vm_flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).anon_vma_list) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_area_struct),
            "::",
            stringify!(anon_vma_list)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).anon_vma) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_area_struct),
            "::",
            stringify!(anon_vma)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).vm_ops) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_area_struct),
            "::",
            stringify!(vm_ops)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ref_count) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_area_struct),
            "::",
            stringify!(ref_count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).page_offset) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_area_struct),
            "::",
            stringify!(page_offset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).private_data) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_area_struct),
            "::",
            stringify!(private_data)
        )
    );
}
#[doc = " @brief 内存空间分布结构体"]
#[doc = " 包含了进程内存空间分布的信息"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mm_struct {
    pub pgd: *mut pml4t_t,
    pub vmas: *mut vm_area_struct,
    pub code_addr_start: u64,
    pub code_addr_end: u64,
    pub data_addr_start: u64,
    pub data_addr_end: u64,
    pub rodata_addr_start: u64,
    pub rodata_addr_end: u64,
    pub bss_start: u64,
    pub bss_end: u64,
    pub brk_start: u64,
    pub brk_end: u64,
    pub stack_start: u64,
}
#[test]
fn bindgen_test_layout_mm_struct() {
    const UNINIT: ::core::mem::MaybeUninit<mm_struct> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<mm_struct>(),
        104usize,
        concat!("Size of: ", stringify!(mm_struct))
    );
    assert_eq!(
        ::core::mem::align_of::<mm_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(mm_struct))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pgd) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct),
            "::",
            stringify!(pgd)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).vmas) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct),
            "::",
            stringify!(vmas)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).code_addr_start) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct),
            "::",
            stringify!(code_addr_start)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).code_addr_end) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct),
            "::",
            stringify!(code_addr_end)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data_addr_start) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct),
            "::",
            stringify!(data_addr_start)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data_addr_end) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct),
            "::",
            stringify!(data_addr_end)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rodata_addr_start) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct),
            "::",
            stringify!(rodata_addr_start)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rodata_addr_end) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct),
            "::",
            stringify!(rodata_addr_end)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bss_start) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct),
            "::",
            stringify!(bss_start)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bss_end) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct),
            "::",
            stringify!(bss_end)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).brk_start) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct),
            "::",
            stringify!(brk_start)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).brk_end) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct),
            "::",
            stringify!(brk_end)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).stack_start) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct),
            "::",
            stringify!(stack_start)
        )
    );
}
#[doc = " @brief 匿名vma对象的结构体"]
#[doc = ""]
#[doc = " anon_vma与每个内存页结构体进行一对一绑定"]
#[doc = " anon_vma也连接着一切使用到该内存页的vma，当发生页面换出时，应当更新与该page相关的所有vma在页表中的映射信息。"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct anon_vma_t {
    pub sem: semaphore_t,
    #[doc = " 记录当前有多少个vma与该anon_vma关联，当vma被释放时，"]
    #[doc = " 应当检查这个值。当该值为0时，应当释放anon_vma结构体"]
    pub ref_count: atomic_t,
    pub vma_list: List,
    pub page: *mut Page,
}
#[test]
fn bindgen_test_layout_anon_vma_t() {
    const UNINIT: ::core::mem::MaybeUninit<anon_vma_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<anon_vma_t>(),
        64usize,
        concat!("Size of: ", stringify!(anon_vma_t))
    );
    assert_eq!(
        ::core::mem::align_of::<anon_vma_t>(),
        8usize,
        concat!("Alignment of ", stringify!(anon_vma_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sem) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(anon_vma_t),
            "::",
            stringify!(sem)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ref_count) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(anon_vma_t),
            "::",
            stringify!(ref_count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).vma_list) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(anon_vma_t),
            "::",
            stringify!(vma_list)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).page) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(anon_vma_t),
            "::",
            stringify!(page)
        )
    );
}
#[doc = " @brief 系统内存信息结构体（单位：字节）"]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mm_stat_t {
    pub total: u64,
    pub used: u64,
    pub free: u64,
    pub shared: u64,
    pub cache_used: u64,
    pub cache_free: u64,
    pub available: u64,
}
#[test]
fn bindgen_test_layout_mm_stat_t() {
    const UNINIT: ::core::mem::MaybeUninit<mm_stat_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<mm_stat_t>(),
        56usize,
        concat!("Size of: ", stringify!(mm_stat_t))
    );
    assert_eq!(
        ::core::mem::align_of::<mm_stat_t>(),
        8usize,
        concat!("Alignment of ", stringify!(mm_stat_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).total) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_stat_t),
            "::",
            stringify!(total)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).used) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_stat_t),
            "::",
            stringify!(used)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).free) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_stat_t),
            "::",
            stringify!(free)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).shared) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_stat_t),
            "::",
            stringify!(shared)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cache_used) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_stat_t),
            "::",
            stringify!(cache_used)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cache_free) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_stat_t),
            "::",
            stringify!(cache_free)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).available) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_stat_t),
            "::",
            stringify!(available)
        )
    );
}
#[doc = " @brief 虚拟内存区域的操作方法的结构体"]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vm_operations_t {
    #[doc = " @brief vm area 被打开时的回调函数"]
    #[doc = ""]
    pub open: ::core::option::Option<unsafe extern "C" fn(area: *mut vm_area_struct)>,
    #[doc = " @brief vm area将要被移除的时候，将会调用该回调函数"]
    #[doc = ""]
    pub close: ::core::option::Option<unsafe extern "C" fn(area: *mut vm_area_struct)>,
}
#[test]
fn bindgen_test_layout_vm_operations_t() {
    const UNINIT: ::core::mem::MaybeUninit<vm_operations_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<vm_operations_t>(),
        16usize,
        concat!("Size of: ", stringify!(vm_operations_t))
    );
    assert_eq!(
        ::core::mem::align_of::<vm_operations_t>(),
        8usize,
        concat!("Alignment of ", stringify!(vm_operations_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).open) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_operations_t),
            "::",
            stringify!(open)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).close) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_operations_t),
            "::",
            stringify!(close)
        )
    );
}
extern "C" {
    pub static mut memory_management_struct: memory_desc;
}
extern "C" {
    pub static mut _text: ::core::ffi::c_char;
}
extern "C" {
    pub static mut _etext: ::core::ffi::c_char;
}
extern "C" {
    pub static mut _data: ::core::ffi::c_char;
}
extern "C" {
    pub static mut _edata: ::core::ffi::c_char;
}
extern "C" {
    pub static mut _rodata: ::core::ffi::c_char;
}
extern "C" {
    pub static mut _erodata: ::core::ffi::c_char;
}
extern "C" {
    pub static mut _bss: ::core::ffi::c_char;
}
extern "C" {
    pub static mut _ebss: ::core::ffi::c_char;
}
extern "C" {
    pub static mut _end: ::core::ffi::c_char;
}
pub const ZONE_DMA_INDEX: ::core::ffi::c_int = 0;
pub const ZONE_NORMAL_INDEX: ::core::ffi::c_int = 0;
pub const ZONE_UNMAPPED_INDEX: ::core::ffi::c_int = 0;
extern "C" {
    pub fn mm_init();
}
extern "C" {
    #[doc = " @brief 初始化内存页"]
    #[doc = ""]
    #[doc = " @param page 内存页结构体"]
    #[doc = " @param flags 标志位"]
    #[doc = " 本函数只负责初始化内存页，允许对同一页面进行多次初始化"]
    #[doc = " 而维护计数器及置位bmp标志位的功能，应当在分配页面的时候手动完成"]
    #[doc = " @return unsigned long"]
    pub fn page_init(page: *mut Page, flags: ul) -> ::core::ffi::c_ulong;
}
extern "C" {
    #[doc = " @brief 读取CR3寄存器的值（存储了页目录的基地址）"]
    #[doc = ""]
    #[doc = " @return unsigned*  cr3的值的指针"]
    pub fn get_CR3() -> *mut ::core::ffi::c_ulong;
}
extern "C" {
    #[doc = " @brief 从已初始化的页结构中搜索符合申请条件的、连续num个struct page"]
    #[doc = ""]
    #[doc = " @param zone_select 选择内存区域, 可选项：dma, mapped in pgt(normal), unmapped in pgt"]
    #[doc = " @param num 需要申请的内存页的数量 num<64"]
    #[doc = " @param flags 将页面属性设置成flag"]
    #[doc = " @return struct Page*"]
    pub fn alloc_pages(
        zone_select: ::core::ffi::c_uint,
        num: ::core::ffi::c_int,
        flags: ul,
    ) -> *mut Page;
}
extern "C" {
    #[doc = " @brief 清除页面的引用计数， 计数为0时清空除页表已映射以外的所有属性"]
    #[doc = ""]
    #[doc = " @param p 物理页结构体"]
    #[doc = " @return unsigned long"]
    pub fn page_clean(page: *mut Page) -> ::core::ffi::c_ulong;
}
extern "C" {
    #[doc = " @brief 释放连续number个内存页"]
    #[doc = ""]
    #[doc = " @param page 第一个要被释放的页面的结构体"]
    #[doc = " @param number 要释放的内存页数量 number<64"]
    pub fn free_pages(page: *mut Page, number: ::core::ffi::c_int);
}
extern "C" {
    #[doc = " @brief Get the page's attr"]
    #[doc = ""]
    #[doc = " @param page 内存页结构体"]
    #[doc = " @return ul 属性"]
    pub fn get_page_attr(page: *mut Page) -> ul;
}
extern "C" {
    #[doc = " @brief Set the page's attr"]
    #[doc = ""]
    #[doc = " @param page 内存页结构体"]
    #[doc = " @param flags  属性"]
    #[doc = " @return ul 错误码"]
    pub fn set_page_attr(page: *mut Page, flags: ul) -> ul;
}
extern "C" {
    #[doc = " @brief 获取一块新的vma结构体，并将其与指定的mm进行绑定"]
    #[doc = ""]
    #[doc = " @param mm 与VMA绑定的内存空间分布结构体"]
    #[doc = " @return struct vm_area_struct* 新的VMA"]
    pub fn vm_area_alloc(mm: *mut mm_struct) -> *mut vm_area_struct;
}
extern "C" {
    #[doc = " @brief 释放vma结构体"]
    #[doc = ""]
    #[doc = " @param vma 待释放的vma结构体"]
    pub fn vm_area_free(vma: *mut vm_area_struct);
}
extern "C" {
    #[doc = " @brief 从链表中删除指定的vma结构体"]
    #[doc = ""]
    #[doc = " @param vma"]
    pub fn vm_area_del(vma: *mut vm_area_struct);
}
extern "C" {
    #[doc = " @brief 查找第一个符合“addr < vm_end”条件的vma"]
    #[doc = ""]
    #[doc = " @param mm 内存空间分布结构体"]
    #[doc = " @param addr 虚拟地址"]
    #[doc = " @return struct vm_area_struct* 符合条件的vma"]
    pub fn vma_find(mm: *mut mm_struct, addr: u64) -> *mut vm_area_struct;
}
extern "C" {
    #[doc = " @brief 插入vma"]
    #[doc = ""]
    #[doc = " @param mm"]
    #[doc = " @param vma"]
    #[doc = " @return int"]
    pub fn vma_insert(mm: *mut mm_struct, vma: *mut vm_area_struct) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief 重新初始化页表的函数"]
    #[doc = " 将所有物理页映射到线性地址空间"]
    pub fn page_table_init();
}
extern "C" {
    #[doc = " @brief 将物理地址映射到页表的函数"]
    #[doc = ""]
    #[doc = " @param virt_addr_start 要映射到的虚拟地址的起始位置"]
    #[doc = " @param phys_addr_start 物理地址的起始位置"]
    #[doc = " @param length 要映射的区域的长度（字节）"]
    #[doc = " @param flags 标志位"]
    #[doc = " @param use4k 是否使用4k页"]
    pub fn mm_map_phys_addr(
        virt_addr_start: ul,
        phys_addr_start: ul,
        length: ul,
        flags: ul,
        use4k: bool,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief 将将物理地址填写到进程的页表的函数"]
    #[doc = ""]
    #[doc = " @param proc_page_table_addr 页表的基地址"]
    #[doc = " @param is_phys 页表的基地址是否为物理地址"]
    #[doc = " @param virt_addr_start 要映射到的虚拟地址的起始位置"]
    #[doc = " @param phys_addr_start 物理地址的起始位置"]
    #[doc = " @param length 要映射的区域的长度（字节）"]
    #[doc = " @param user 用户态是否可访问"]
    #[doc = " @param flush 是否刷新tlb"]
    #[doc = " @param use4k 是否使用4k页"]
    pub fn mm_map_proc_page_table(
        proc_page_table_addr: ul,
        is_phys: bool,
        virt_addr_start: ul,
        phys_addr_start: ul,
        length: ul,
        flags: ul,
        user: bool,
        flush: bool,
        use4k: bool,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn mm_map_phys_addr_user(
        virt_addr_start: ul,
        phys_addr_start: ul,
        length: ul,
        flags: ul,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief 从页表中清除虚拟地址的映射"]
    #[doc = ""]
    #[doc = " @param proc_page_table_addr 页表的地址"]
    #[doc = " @param is_phys 页表地址是否为物理地址"]
    #[doc = " @param virt_addr_start 要清除的虚拟地址的起始地址"]
    #[doc = " @param length 要清除的区域的长度"]
    pub fn mm_unmap_proc_table(
        proc_page_table_addr: ul,
        is_phys: bool,
        virt_addr_start: ul,
        length: ul,
    );
}
extern "C" {
    #[doc = " @brief 创建VMA"]
    #[doc = ""]
    #[doc = " @param mm 要绑定的内存空间分布结构体"]
    #[doc = " @param vaddr 起始虚拟地址"]
    #[doc = " @param length 长度（字节）"]
    #[doc = " @param vm_flags vma的标志"]
    #[doc = " @param vm_ops vma的操作接口"]
    #[doc = " @param res_vma 返回的vma指针"]
    #[doc = " @return int 错误码"]
    pub fn mm_create_vma(
        mm: *mut mm_struct,
        vaddr: u64,
        length: u64,
        vm_flags: vm_flags_t,
        vm_ops: *mut vm_operations_t,
        res_vma: *mut *mut vm_area_struct,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief 将指定的物理地址映射到指定的vma处"]
    #[doc = ""]
    #[doc = " @param vma 要进行映射的VMA结构体"]
    #[doc = " @param paddr 起始物理地址"]
    #[doc = " @param offset 要映射的起始位置在vma中的偏移量"]
    #[doc = " @param length 要映射的长度"]
    #[doc = " @return int 错误码"]
    pub fn mm_map_vma(
        vma: *mut vm_area_struct,
        paddr: u64,
        offset: u64,
        length: u64,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief 在页表中映射物理地址到指定的虚拟地址（需要页表中已存在对应的vma）"]
    #[doc = ""]
    #[doc = " @param mm 内存管理结构体"]
    #[doc = " @param vaddr 虚拟地址"]
    #[doc = " @param length 长度（字节）"]
    #[doc = " @param paddr 物理地址"]
    #[doc = " @return int 返回码"]
    pub fn mm_map(mm: *mut mm_struct, vaddr: u64, length: u64, paddr: u64) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief 在页表中取消指定的vma的映射"]
    #[doc = ""]
    #[doc = " @param mm 指定的mm"]
    #[doc = " @param vma 待取消映射的vma"]
    #[doc = " @param paddr 返回的被取消映射的起始物理地址"]
    #[doc = " @return int 返回码"]
    pub fn mm_unmap_vma(
        mm: *mut mm_struct,
        vma: *mut vm_area_struct,
        paddr: *mut u64,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief 解除一段虚拟地址的映射（这些地址必须在vma中存在）"]
    #[doc = ""]
    #[doc = " @param mm 内存空间结构体"]
    #[doc = " @param vaddr 起始地址"]
    #[doc = " @param length 结束地址"]
    #[doc = " @param destroy 是否释放vma结构体"]
    #[doc = " @return int 错误码"]
    pub fn mm_unmap(
        mm: *mut mm_struct,
        vaddr: u64,
        length: u64,
        destroy: bool,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief 检测是否为有效的2M页(物理内存页)"]
    #[doc = ""]
    #[doc = " @param paddr 物理地址"]
    #[doc = " @return int8_t 是 -> 1"]
    #[doc = "                 否 -> 0"]
    pub fn mm_is_2M_page(paddr: u64) -> i8;
}
extern "C" {
    #[doc = " @brief 检查页表是否存在不为0的页表项"]
    #[doc = ""]
    #[doc = " @param ptr 页表基指针"]
    #[doc = " @return int8_t 存在 -> 1"]
    #[doc = "                不存在 -> 0"]
    pub fn mm_check_page_table(ptr: *mut u64) -> i8;
}
extern "C" {
    #[doc = " @brief 调整堆区域的大小（暂时只能增加堆区域）"]
    #[doc = ""]
    #[doc = " @todo 缩小堆区域"]
    #[doc = " @param old_brk_end_addr 原本的堆内存区域的结束地址"]
    #[doc = " @param offset 新的地址相对于原地址的偏移量"]
    #[doc = " @return uint64_t"]
    pub fn mm_do_brk(old_brk_end_addr: u64, offset: i64) -> u64;
}
extern "C" {
    #[doc = " @brief 获取系统当前的内存信息(未上锁，不一定精准)"]
    #[doc = ""]
    #[doc = " @return struct mm_stat_t 内存信息结构体"]
    pub fn mm_stat() -> mm_stat_t;
}
extern "C" {
    #[doc = " @brief 检测指定地址是否已经被映射"]
    #[doc = ""]
    #[doc = " @param page_table_phys_addr 页表的物理地址"]
    #[doc = " @param virt_addr 要检测的地址"]
    #[doc = " @return true 已经被映射"]
    #[doc = " @return false"]
    pub fn mm_check_mapped(page_table_phys_addr: ul, virt_addr: u64) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct slab_obj {
    pub list: List,
    pub page: *mut Page,
    pub count_using: ul,
    pub count_free: ul,
    pub vaddr: *mut ::core::ffi::c_void,
    pub bmp_len: ul,
    pub bmp_count: ul,
    pub bmp: *mut ul,
}
#[test]
fn bindgen_test_layout_slab_obj() {
    const UNINIT: ::core::mem::MaybeUninit<slab_obj> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<slab_obj>(),
        72usize,
        concat!("Size of: ", stringify!(slab_obj))
    );
    assert_eq!(
        ::core::mem::align_of::<slab_obj>(),
        8usize,
        concat!("Alignment of ", stringify!(slab_obj))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).list) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(slab_obj),
            "::",
            stringify!(list)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).page) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(slab_obj),
            "::",
            stringify!(page)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).count_using) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(slab_obj),
            "::",
            stringify!(count_using)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).count_free) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(slab_obj),
            "::",
            stringify!(count_free)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).vaddr) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(slab_obj),
            "::",
            stringify!(vaddr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bmp_len) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(slab_obj),
            "::",
            stringify!(bmp_len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bmp_count) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(slab_obj),
            "::",
            stringify!(bmp_count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bmp) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(slab_obj),
            "::",
            stringify!(bmp)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct slab {
    pub size: ul,
    pub count_total_using: ul,
    pub count_total_free: ul,
    pub cache_pool_entry: *mut slab_obj,
    pub cache_dma_pool_entry: *mut slab_obj,
    pub lock: spinlock_t,
    pub constructor: ::core::option::Option<
        unsafe extern "C" fn(vaddr: *mut ::core::ffi::c_void, arg: ul) -> *mut ::core::ffi::c_void,
    >,
    pub destructor: ::core::option::Option<
        unsafe extern "C" fn(vaddr: *mut ::core::ffi::c_void, arg: ul) -> *mut ::core::ffi::c_void,
    >,
}
#[test]
fn bindgen_test_layout_slab() {
    const UNINIT: ::core::mem::MaybeUninit<slab> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<slab>(),
        64usize,
        concat!("Size of: ", stringify!(slab))
    );
    assert_eq!(
        ::core::mem::align_of::<slab>(),
        8usize,
        concat!("Alignment of ", stringify!(slab))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(slab),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).count_total_using) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(slab),
            "::",
            stringify!(count_total_using)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).count_total_free) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(slab),
            "::",
            stringify!(count_total_free)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cache_pool_entry) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(slab),
            "::",
            stringify!(cache_pool_entry)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cache_dma_pool_entry) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(slab),
            "::",
            stringify!(cache_dma_pool_entry)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).lock) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(slab),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).constructor) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(slab),
            "::",
            stringify!(constructor)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).destructor) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(slab),
            "::",
            stringify!(destructor)
        )
    );
}
extern "C" {
    #[doc = " @brief 通用内存分配函数"]
    #[doc = ""]
    #[doc = " @param size 要分配的内存大小"]
    #[doc = " @param gfp 内存的flag"]
    #[doc = " @return void* 分配得到的内存的指针"]
    pub fn kmalloc(size: ::core::ffi::c_ulong, gfp: gfp_t) -> *mut ::core::ffi::c_void;
}
extern "C" {
    #[doc = " @brief 通用内存释放函数"]
    #[doc = ""]
    #[doc = " @param address 要释放的内存地址"]
    #[doc = " @return unsigned long"]
    pub fn kfree(address: *mut ::core::ffi::c_void) -> ::core::ffi::c_ulong;
}
extern "C" {
    #[doc = " @brief 创建一个内存池"]
    #[doc = ""]
    #[doc = " @param size 内存池容量大小"]
    #[doc = " @param constructor 构造函数"]
    #[doc = " @param destructor 析构函数"]
    #[doc = " @param arg 参数"]
    #[doc = " @return struct slab* 构建好的内存池对象"]
    pub fn slab_create(
        size: ul,
        constructor: ::core::option::Option<
            unsafe extern "C" fn(
                vaddr: *mut ::core::ffi::c_void,
                arg: ul,
            ) -> *mut ::core::ffi::c_void,
        >,
        destructor: ::core::option::Option<
            unsafe extern "C" fn(
                vaddr: *mut ::core::ffi::c_void,
                arg: ul,
            ) -> *mut ::core::ffi::c_void,
        >,
        arg: ul,
    ) -> *mut slab;
}
extern "C" {
    #[doc = " @brief 销毁内存池对象"]
    #[doc = " 只有当slab对象是空的时候才能销毁"]
    #[doc = " @param slab_pool 要销毁的内存池对象"]
    #[doc = " @return ul"]
    #[doc = ""]
    pub fn slab_destroy(slab_pool: *mut slab) -> ul;
}
extern "C" {
    #[doc = " @brief 分配SLAB内存池中的内存对象"]
    #[doc = ""]
    #[doc = " @param slab_pool slab内存池"]
    #[doc = " @param arg 传递给内存对象构造函数的参数"]
    #[doc = " @return void* 内存空间的虚拟地址"]
    pub fn slab_malloc(slab_pool: *mut slab, arg: ul) -> *mut ::core::ffi::c_void;
}
extern "C" {
    #[doc = " @brief 回收slab内存池中的对象"]
    #[doc = ""]
    #[doc = " @param slab_pool 对应的内存池"]
    #[doc = " @param addr 内存对象的虚拟地址"]
    #[doc = " @param arg 传递给虚构函数的参数"]
    #[doc = " @return ul"]
    pub fn slab_free(slab_pool: *mut slab, addr: *mut ::core::ffi::c_void, arg: ul) -> ul;
}
extern "C" {
    #[doc = " @brief 在kmalloc中创建slab_obj的函数（与slab_malloc()类似)"]
    #[doc = ""]
    #[doc = " @param size"]
    #[doc = " @return struct slab_obj* 创建好的slab_obj"]
    pub fn kmalloc_create_slab_obj(size: ul) -> *mut slab_obj;
}
extern "C" {
    #[doc = " @brief 初始化内存池组"]
    #[doc = " 在初始化通用内存管理单元期间，尚无内存空间分配函数，需要我们手动为SLAB内存池指定存储空间"]
    #[doc = " @return ul"]
    pub fn slab_init() -> ul;
}
extern "C" {
    pub static mut vfs_root_sb: *mut vfs_superblock_t;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct vfs_dir_entry_t {
    pub name: *mut ::core::ffi::c_char,
    pub name_length: ::core::ffi::c_int,
    pub d_flags: u32,
    pub child_node_list: List,
    pub subdirs_list: List,
    pub lockref: lockref,
    pub dir_inode: *mut vfs_index_node_t,
    pub parent: *mut vfs_dir_entry_t,
    pub dir_ops: *mut vfs_dir_entry_operations_t,
}
#[test]
fn bindgen_test_layout_vfs_dir_entry_t() {
    const UNINIT: ::core::mem::MaybeUninit<vfs_dir_entry_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<vfs_dir_entry_t>(),
        80usize,
        concat!("Size of: ", stringify!(vfs_dir_entry_t))
    );
    assert_eq!(
        ::core::mem::align_of::<vfs_dir_entry_t>(),
        8usize,
        concat!("Alignment of ", stringify!(vfs_dir_entry_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vfs_dir_entry_t),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).name_length) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vfs_dir_entry_t),
            "::",
            stringify!(name_length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).d_flags) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(vfs_dir_entry_t),
            "::",
            stringify!(d_flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).child_node_list) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vfs_dir_entry_t),
            "::",
            stringify!(child_node_list)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).subdirs_list) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(vfs_dir_entry_t),
            "::",
            stringify!(subdirs_list)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).lockref) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(vfs_dir_entry_t),
            "::",
            stringify!(lockref)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dir_inode) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(vfs_dir_entry_t),
            "::",
            stringify!(dir_inode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(vfs_dir_entry_t),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dir_ops) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(vfs_dir_entry_t),
            "::",
            stringify!(dir_ops)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vfs_superblock_t {
    pub root: *mut vfs_dir_entry_t,
    pub sb_ops: *mut vfs_super_block_operations_t,
    pub dir_ops: *mut vfs_dir_entry_operations_t,
    pub blk_device: *mut block_device,
    pub private_sb_info: *mut ::core::ffi::c_void,
}
#[test]
fn bindgen_test_layout_vfs_superblock_t() {
    const UNINIT: ::core::mem::MaybeUninit<vfs_superblock_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<vfs_superblock_t>(),
        40usize,
        concat!("Size of: ", stringify!(vfs_superblock_t))
    );
    assert_eq!(
        ::core::mem::align_of::<vfs_superblock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(vfs_superblock_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).root) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vfs_superblock_t),
            "::",
            stringify!(root)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sb_ops) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vfs_superblock_t),
            "::",
            stringify!(sb_ops)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dir_ops) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vfs_superblock_t),
            "::",
            stringify!(dir_ops)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).blk_device) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(vfs_superblock_t),
            "::",
            stringify!(blk_device)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).private_sb_info) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(vfs_superblock_t),
            "::",
            stringify!(private_sb_info)
        )
    );
}
#[doc = " @brief inode结构体"]
#[doc = ""]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct vfs_index_node_t {
    pub file_size: u64,
    pub blocks: u64,
    pub attribute: u64,
    pub lockref: lockref,
    pub sb: *mut vfs_superblock_t,
    pub file_ops: *mut vfs_file_operations_t,
    pub inode_ops: *mut vfs_inode_operations_t,
    pub private_inode_info: *mut ::core::ffi::c_void,
}
#[test]
fn bindgen_test_layout_vfs_index_node_t() {
    const UNINIT: ::core::mem::MaybeUninit<vfs_index_node_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<vfs_index_node_t>(),
        64usize,
        concat!("Size of: ", stringify!(vfs_index_node_t))
    );
    assert_eq!(
        ::core::mem::align_of::<vfs_index_node_t>(),
        8usize,
        concat!("Alignment of ", stringify!(vfs_index_node_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).file_size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vfs_index_node_t),
            "::",
            stringify!(file_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).blocks) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vfs_index_node_t),
            "::",
            stringify!(blocks)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).attribute) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vfs_index_node_t),
            "::",
            stringify!(attribute)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).lockref) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(vfs_index_node_t),
            "::",
            stringify!(lockref)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sb) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(vfs_index_node_t),
            "::",
            stringify!(sb)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).file_ops) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(vfs_index_node_t),
            "::",
            stringify!(file_ops)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).inode_ops) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(vfs_index_node_t),
            "::",
            stringify!(inode_ops)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).private_inode_info) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(vfs_index_node_t),
            "::",
            stringify!(private_inode_info)
        )
    );
}
#[doc = " @brief 文件描述符"]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vfs_file_t {
    pub position: ::core::ffi::c_long,
    pub mode: u64,
    pub dEntry: *mut vfs_dir_entry_t,
    pub file_ops: *mut vfs_file_operations_t,
    pub private_data: *mut ::core::ffi::c_void,
}
#[test]
fn bindgen_test_layout_vfs_file_t() {
    const UNINIT: ::core::mem::MaybeUninit<vfs_file_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<vfs_file_t>(),
        40usize,
        concat!("Size of: ", stringify!(vfs_file_t))
    );
    assert_eq!(
        ::core::mem::align_of::<vfs_file_t>(),
        8usize,
        concat!("Alignment of ", stringify!(vfs_file_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).position) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vfs_file_t),
            "::",
            stringify!(position)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mode) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vfs_file_t),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dEntry) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vfs_file_t),
            "::",
            stringify!(dEntry)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).file_ops) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(vfs_file_t),
            "::",
            stringify!(file_ops)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).private_data) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(vfs_file_t),
            "::",
            stringify!(private_data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vfs_filesystem_type_t {
    pub name: *mut ::core::ffi::c_char,
    pub fs_flags: ::core::ffi::c_int,
    pub read_superblock: ::core::option::Option<
        unsafe extern "C" fn(blk: *mut block_device) -> *mut vfs_superblock_t,
    >,
    pub next: *mut vfs_filesystem_type_t,
}
#[test]
fn bindgen_test_layout_vfs_filesystem_type_t() {
    const UNINIT: ::core::mem::MaybeUninit<vfs_filesystem_type_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<vfs_filesystem_type_t>(),
        32usize,
        concat!("Size of: ", stringify!(vfs_filesystem_type_t))
    );
    assert_eq!(
        ::core::mem::align_of::<vfs_filesystem_type_t>(),
        8usize,
        concat!("Alignment of ", stringify!(vfs_filesystem_type_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vfs_filesystem_type_t),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fs_flags) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vfs_filesystem_type_t),
            "::",
            stringify!(fs_flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).read_superblock) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vfs_filesystem_type_t),
            "::",
            stringify!(read_superblock)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(vfs_filesystem_type_t),
            "::",
            stringify!(next)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vfs_super_block_operations_t {
    pub write_superblock: ::core::option::Option<unsafe extern "C" fn(sb: *mut vfs_superblock_t)>,
    pub put_superblock: ::core::option::Option<unsafe extern "C" fn(sb: *mut vfs_superblock_t)>,
    pub write_inode: ::core::option::Option<unsafe extern "C" fn(inode: *mut vfs_index_node_t)>,
}
#[test]
fn bindgen_test_layout_vfs_super_block_operations_t() {
    const UNINIT: ::core::mem::MaybeUninit<vfs_super_block_operations_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<vfs_super_block_operations_t>(),
        24usize,
        concat!("Size of: ", stringify!(vfs_super_block_operations_t))
    );
    assert_eq!(
        ::core::mem::align_of::<vfs_super_block_operations_t>(),
        8usize,
        concat!("Alignment of ", stringify!(vfs_super_block_operations_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).write_superblock) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vfs_super_block_operations_t),
            "::",
            stringify!(write_superblock)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).put_superblock) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vfs_super_block_operations_t),
            "::",
            stringify!(put_superblock)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).write_inode) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vfs_super_block_operations_t),
            "::",
            stringify!(write_inode)
        )
    );
}
#[doc = " @brief 对vfs的inode的操作抽象"]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vfs_inode_operations_t {
    #[doc = " @brief 创建新的文件"]
    #[doc = " @param parent_inode 父目录的inode结构体"]
    #[doc = " @param dest_dEntry 新文件的dentry"]
    #[doc = " @param mode 创建模式"]
    pub create: ::core::option::Option<
        unsafe extern "C" fn(
            parent_inode: *mut vfs_index_node_t,
            dest_dEntry: *mut vfs_dir_entry_t,
            mode: ::core::ffi::c_int,
        ) -> ::core::ffi::c_long,
    >,
    #[doc = " @brief 在文件系统中查找指定的目录项"]
    #[doc = " @param parent_inode 父目录项（在这个目录下查找）"]
    #[doc = " @param dest_dEntry 构造的目标目录项的结构体（传入名称，然后更多的详细信息将在本函数中完成填写）"]
    #[doc = ""]
    pub lookup: ::core::option::Option<
        unsafe extern "C" fn(
            parent_inode: *mut vfs_index_node_t,
            dest_dEntry: *mut vfs_dir_entry_t,
        ) -> *mut vfs_dir_entry_t,
    >,
    #[doc = " @brief 创建文件夹"]
    #[doc = " @param inode 父目录的inode"]
    #[doc = " @param dEntry 新的文件夹的dentry"]
    #[doc = " @param mode 创建文件夹的mode"]
    pub mkdir: ::core::option::Option<
        unsafe extern "C" fn(
            inode: *mut vfs_index_node_t,
            dEntry: *mut vfs_dir_entry_t,
            mode: ::core::ffi::c_int,
        ) -> ::core::ffi::c_long,
    >,
    pub rmdir: ::core::option::Option<
        unsafe extern "C" fn(
            inode: *mut vfs_index_node_t,
            dEntry: *mut vfs_dir_entry_t,
        ) -> ::core::ffi::c_long,
    >,
    pub rename: ::core::option::Option<
        unsafe extern "C" fn(
            old_inode: *mut vfs_index_node_t,
            old_dEntry: *mut vfs_dir_entry_t,
            new_inode: *mut vfs_index_node_t,
            new_dEntry: *mut vfs_dir_entry_t,
        ) -> ::core::ffi::c_long,
    >,
    pub getAttr: ::core::option::Option<
        unsafe extern "C" fn(dEntry: *mut vfs_dir_entry_t, attr: *mut u64) -> ::core::ffi::c_long,
    >,
    pub setAttr: ::core::option::Option<
        unsafe extern "C" fn(dEntry: *mut vfs_dir_entry_t, attr: *mut u64) -> ::core::ffi::c_long,
    >,
    #[doc = " @brief 取消inode和dentry之间的链接关系（删除文件）"]
    #[doc = ""]
    #[doc = " @param inode 要被取消关联关系的目录项的【父目录项】"]
    #[doc = " @param dentry 要被取消关联关系的子目录项"]
    pub unlink: ::core::option::Option<
        unsafe extern "C" fn(
            inode: *mut vfs_index_node_t,
            dentry: *mut vfs_dir_entry_t,
        ) -> ::core::ffi::c_long,
    >,
}
#[test]
fn bindgen_test_layout_vfs_inode_operations_t() {
    const UNINIT: ::core::mem::MaybeUninit<vfs_inode_operations_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<vfs_inode_operations_t>(),
        64usize,
        concat!("Size of: ", stringify!(vfs_inode_operations_t))
    );
    assert_eq!(
        ::core::mem::align_of::<vfs_inode_operations_t>(),
        8usize,
        concat!("Alignment of ", stringify!(vfs_inode_operations_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).create) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vfs_inode_operations_t),
            "::",
            stringify!(create)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).lookup) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vfs_inode_operations_t),
            "::",
            stringify!(lookup)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mkdir) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vfs_inode_operations_t),
            "::",
            stringify!(mkdir)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rmdir) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(vfs_inode_operations_t),
            "::",
            stringify!(rmdir)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rename) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(vfs_inode_operations_t),
            "::",
            stringify!(rename)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).getAttr) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(vfs_inode_operations_t),
            "::",
            stringify!(getAttr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).setAttr) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(vfs_inode_operations_t),
            "::",
            stringify!(setAttr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).unlink) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(vfs_inode_operations_t),
            "::",
            stringify!(unlink)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vfs_dir_entry_operations_t {
    pub compare: ::core::option::Option<
        unsafe extern "C" fn(
            parent_dEntry: *mut vfs_dir_entry_t,
            source_filename: *mut ::core::ffi::c_char,
            dest_filename: *mut ::core::ffi::c_char,
        ) -> ::core::ffi::c_long,
    >,
    pub hash: ::core::option::Option<
        unsafe extern "C" fn(
            dEntry: *mut vfs_dir_entry_t,
            filename: *mut ::core::ffi::c_char,
        ) -> ::core::ffi::c_long,
    >,
    pub release: ::core::option::Option<
        unsafe extern "C" fn(dEntry: *mut vfs_dir_entry_t) -> ::core::ffi::c_long,
    >,
    pub iput: ::core::option::Option<
        unsafe extern "C" fn(
            dEntry: *mut vfs_dir_entry_t,
            inode: *mut vfs_index_node_t,
        ) -> ::core::ffi::c_long,
    >,
}
#[test]
fn bindgen_test_layout_vfs_dir_entry_operations_t() {
    const UNINIT: ::core::mem::MaybeUninit<vfs_dir_entry_operations_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<vfs_dir_entry_operations_t>(),
        32usize,
        concat!("Size of: ", stringify!(vfs_dir_entry_operations_t))
    );
    assert_eq!(
        ::core::mem::align_of::<vfs_dir_entry_operations_t>(),
        8usize,
        concat!("Alignment of ", stringify!(vfs_dir_entry_operations_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).compare) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vfs_dir_entry_operations_t),
            "::",
            stringify!(compare)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hash) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vfs_dir_entry_operations_t),
            "::",
            stringify!(hash)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).release) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vfs_dir_entry_operations_t),
            "::",
            stringify!(release)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).iput) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(vfs_dir_entry_operations_t),
            "::",
            stringify!(iput)
        )
    );
}
#[doc = " @brief 填充dirent的函数指针的类型定义"]
#[doc = ""]
pub type vfs_filldir_t = ::core::option::Option<
    unsafe extern "C" fn(
        buf: *mut ::core::ffi::c_void,
        d_ino: ino_t,
        name: *mut ::core::ffi::c_char,
        namelen: ::core::ffi::c_int,
        type_: ::core::ffi::c_uchar,
        offset: off_t,
    ) -> ::core::ffi::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vfs_file_operations_t {
    pub open: ::core::option::Option<
        unsafe extern "C" fn(
            inode: *mut vfs_index_node_t,
            file_ptr: *mut vfs_file_t,
        ) -> ::core::ffi::c_long,
    >,
    pub close: ::core::option::Option<
        unsafe extern "C" fn(
            inode: *mut vfs_index_node_t,
            file_ptr: *mut vfs_file_t,
        ) -> ::core::ffi::c_long,
    >,
    pub read: ::core::option::Option<
        unsafe extern "C" fn(
            file_ptr: *mut vfs_file_t,
            buf: *mut ::core::ffi::c_char,
            count: i64,
            position: *mut ::core::ffi::c_long,
        ) -> ::core::ffi::c_long,
    >,
    pub write: ::core::option::Option<
        unsafe extern "C" fn(
            file_ptr: *mut vfs_file_t,
            buf: *mut ::core::ffi::c_char,
            count: i64,
            position: *mut ::core::ffi::c_long,
        ) -> ::core::ffi::c_long,
    >,
    pub lseek: ::core::option::Option<
        unsafe extern "C" fn(
            file_ptr: *mut vfs_file_t,
            offset: ::core::ffi::c_long,
            origin: ::core::ffi::c_long,
        ) -> ::core::ffi::c_long,
    >,
    pub ioctl: ::core::option::Option<
        unsafe extern "C" fn(
            inode: *mut vfs_index_node_t,
            file_ptr: *mut vfs_file_t,
            cmd: u64,
            arg: u64,
        ) -> ::core::ffi::c_long,
    >,
    pub readdir: ::core::option::Option<
        unsafe extern "C" fn(
            file_ptr: *mut vfs_file_t,
            dirent: *mut ::core::ffi::c_void,
            filler: vfs_filldir_t,
        ) -> ::core::ffi::c_long,
    >,
}
#[test]
fn bindgen_test_layout_vfs_file_operations_t() {
    const UNINIT: ::core::mem::MaybeUninit<vfs_file_operations_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<vfs_file_operations_t>(),
        56usize,
        concat!("Size of: ", stringify!(vfs_file_operations_t))
    );
    assert_eq!(
        ::core::mem::align_of::<vfs_file_operations_t>(),
        8usize,
        concat!("Alignment of ", stringify!(vfs_file_operations_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).open) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vfs_file_operations_t),
            "::",
            stringify!(open)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).close) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vfs_file_operations_t),
            "::",
            stringify!(close)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).read) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vfs_file_operations_t),
            "::",
            stringify!(read)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).write) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(vfs_file_operations_t),
            "::",
            stringify!(write)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).lseek) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(vfs_file_operations_t),
            "::",
            stringify!(lseek)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ioctl) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(vfs_file_operations_t),
            "::",
            stringify!(ioctl)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).readdir) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(vfs_file_operations_t),
            "::",
            stringify!(readdir)
        )
    );
}
extern "C" {
    #[doc = " @brief 在VFS中注册文件系统"]
    #[doc = ""]
    #[doc = " @param fs 文件系统类型结构体"]
    #[doc = " @return uint64_t"]
    pub fn vfs_register_filesystem(fs: *mut vfs_filesystem_type_t) -> u64;
}
extern "C" {
    pub fn vfs_unregister_filesystem(fs: *mut vfs_filesystem_type_t) -> u64;
}
extern "C" {
    #[doc = " @brief 挂载文件系统"]
    #[doc = ""]
    #[doc = " @param path 要挂载到的路径"]
    #[doc = " @param name 文件系统名"]
    #[doc = " @param blk 块设备结构体"]
    #[doc = " @return struct vfs_superblock_t* 挂载后，文件系统的超级块"]
    pub fn vfs_mount_fs(
        path: *const ::core::ffi::c_char,
        name: *mut ::core::ffi::c_char,
        blk: *mut block_device,
    ) -> *mut vfs_superblock_t;
}
extern "C" {
    #[doc = " @brief 按照路径查找文件"]
    #[doc = ""]
    #[doc = " @param path 路径"]
    #[doc = " @param flags 1：返回父目录项， 0：返回结果目录项"]
    #[doc = " @return struct vfs_dir_entry_t* 目录项"]
    pub fn vfs_path_walk(path: *const ::core::ffi::c_char, flags: u64) -> *mut vfs_dir_entry_t;
}
extern "C" {
    #[doc = " @brief 填充dentry"]
    #[doc = ""]
    pub fn vfs_fill_dirent(
        buf: *mut ::core::ffi::c_void,
        d_ino: ino_t,
        name: *mut ::core::ffi::c_char,
        namelen: ::core::ffi::c_int,
        type_: ::core::ffi::c_uchar,
        offset: off_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief 初始化vfs"]
    #[doc = ""]
    #[doc = " @return int 错误码"]
    pub fn vfs_init() -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief 动态分配dentry以及路径字符串名称"]
    #[doc = ""]
    #[doc = " @param name_size 名称字符串大小（字节）(注意考虑字符串最后需要有一个‘\\0’作为结尾)"]
    #[doc = " @return struct vfs_dir_entry_t* 创建好的dentry"]
    pub fn vfs_alloc_dentry(name_size: ::core::ffi::c_int) -> *mut vfs_dir_entry_t;
}
extern "C" {
    #[doc = " @brief 分配inode并将引用计数初始化为1"]
    #[doc = ""]
    #[doc = " @return struct vfs_index_node_t * 分配得到的inode"]
    pub fn vfs_alloc_inode() -> *mut vfs_index_node_t;
}
extern "C" {
    #[doc = " @brief 打开文件"]
    #[doc = ""]
    #[doc = " @param filename 文件路径"]
    #[doc = " @param flags 标志位"]
    #[doc = " @return uint64_t 错误码"]
    pub fn do_open(filename: *const ::core::ffi::c_char, flags: ::core::ffi::c_int) -> u64;
}
extern "C" {
    #[doc = " @brief 创建文件夹"]
    #[doc = ""]
    #[doc = " @param path 文件夹路径"]
    #[doc = " @param mode 创建模式"]
    #[doc = " @param from_userland 该创建请求是否来自用户态"]
    #[doc = " @return int64_t 错误码"]
    pub fn vfs_mkdir(path: *const ::core::ffi::c_char, mode: mode_t, from_userland: bool) -> i64;
}
extern "C" {
    #[doc = " @brief 删除文件夹"]
    #[doc = ""]
    #[doc = " @param path 文件夹路径"]
    #[doc = " @param from_userland 请求是否来自用户态"]
    #[doc = " @return int64_t 错误码"]
    pub fn vfs_rmdir(path: *const ::core::ffi::c_char, from_userland: bool) -> i64;
}
extern "C" {
    #[doc = " @brief 释放dentry，并视情况自动释放inode。 在调用该函数前，需要将dentry加锁。"]
    #[doc = ""]
    #[doc = " @param dentry 目标dentry"]
    #[doc = ""]
    #[doc = " @return 错误码"]
    #[doc = "          注意，当dentry指向文件时，如果返回值为正数，则表示在释放了该dentry后，该dentry指向的inode的引用计数。"]
    pub fn vfs_dentry_put(dentry: *mut vfs_dir_entry_t) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn vfs_unlink(
        mnt_userns: *mut user_namespace,
        parent_inode: *mut vfs_index_node_t,
        dentry: *mut vfs_dir_entry_t,
        delegated_inode: *mut *mut vfs_index_node_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn do_unlink_at(
        dfd: ::core::ffi::c_int,
        pathname: *const ::core::ffi::c_char,
        name: bool,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief 初始化系统的第一个进程"]
    #[doc = ""]
    pub fn process_init();
}
extern "C" {
    #[doc = " @brief fork当前进程"]
    #[doc = ""]
    #[doc = " @param regs 新的寄存器值"]
    #[doc = " @param clone_flags 克隆标志"]
    #[doc = " @param stack_start 堆栈开始地址"]
    #[doc = " @param stack_size 堆栈大小"]
    #[doc = " @return unsigned long"]
    pub fn do_fork(
        regs: *mut pt_regs,
        clone_flags: ::core::ffi::c_ulong,
        stack_start: ::core::ffi::c_ulong,
        stack_size: ::core::ffi::c_ulong,
    ) -> ::core::ffi::c_ulong;
}
extern "C" {
    #[doc = " @brief 根据pid获取进程的pcb"]
    #[doc = ""]
    #[doc = " @param pid"]
    #[doc = " @return struct process_control_block*"]
    pub fn process_get_pcb(pid: ::core::ffi::c_long) -> *mut process_control_block;
}
extern "C" {
    #[doc = " @brief 将进程加入到调度器的就绪队列中"]
    #[doc = ""]
    #[doc = " @param pcb 进程的pcb"]
    pub fn process_wakeup(pcb: *mut process_control_block) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief 将进程加入到调度器的就绪队列中，并标志当前进程需要被调度"]
    #[doc = ""]
    #[doc = " @param pcb 进程的pcb"]
    pub fn process_wakeup_immediately(pcb: *mut process_control_block) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief 使当前进程去执行新的代码"]
    #[doc = ""]
    #[doc = " @param regs 当前进程的寄存器"]
    #[doc = " @param path 可执行程序的路径"]
    #[doc = " @param argv 参数列表"]
    #[doc = " @param envp 环境变量"]
    #[doc = " @return ul 错误码"]
    pub fn do_execve(
        regs: *mut pt_regs,
        path: *mut ::core::ffi::c_char,
        argv: *mut *mut ::core::ffi::c_char,
        envp: *mut *mut ::core::ffi::c_char,
    ) -> ul;
}
extern "C" {
    #[doc = " @brief 释放进程的页表"]
    #[doc = ""]
    #[doc = " @param pcb 要被释放页表的进程"]
    #[doc = " @return uint64_t"]
    pub fn process_exit_mm(pcb: *mut process_control_block) -> u64;
}
extern "C" {
    #[doc = " @brief 进程退出时执行的函数"]
    #[doc = ""]
    #[doc = " @param code 返回码"]
    #[doc = " @return ul"]
    pub fn process_do_exit(code: ul) -> ul;
}
extern "C" {
    #[doc = " @brief 当子进程退出后向父进程发送通知"]
    #[doc = ""]
    pub fn process_exit_notify();
}
extern "C" {
    #[doc = " @brief 初始化内核进程"]
    #[doc = ""]
    #[doc = " @param fn 目标程序的地址"]
    #[doc = " @param arg 向目标程序传入的参数"]
    #[doc = " @param flags"]
    #[doc = " @return int"]
    pub fn kernel_thread(
        fn_: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void) -> ::core::ffi::c_int,
        >,
        arg: *mut ::core::ffi::c_void,
        flags: ::core::ffi::c_ulong,
    ) -> u64;
}
extern "C" {
    pub fn process_fd_alloc(file: *mut vfs_file_t) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn process_release_pcb(pcb: *mut process_control_block) -> ::core::ffi::c_int;
}
extern "C" {
    pub static mut head_stack_start: ::core::ffi::c_ulong;
}
extern "C" {
    pub static mut _stack_start: ul;
}
extern "C" {
    pub fn ret_from_intr();
}
extern "C" {
    pub static mut initial_tss: [tss_struct; 32usize];
}
extern "C" {
    pub static mut initial_mm: mm_struct;
}
extern "C" {
    pub static mut initial_thread: thread_struct;
}
extern "C" {
    pub static mut initial_proc_union: proc_union;
}
extern "C" {
    pub static mut initial_proc: [*mut process_control_block; 32usize];
}
extern "C" {
    #[doc = " @brief 给pcb设置名字"]
    #[doc = ""]
    #[doc = " @param pcb 需要设置名字的pcb"]
    #[doc = " @param pcb_name 保存名字的char数组"]
    pub fn process_set_pcb_name(
        pcb: *mut process_control_block,
        pcb_name: *const ::core::ffi::c_char,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sched_queue_t {
    pub count: ::core::ffi::c_long,
    pub cpu_exec_proc_jiffies: ::core::ffi::c_long,
    pub proc_queue: process_control_block,
}
#[test]
fn bindgen_test_layout_sched_queue_t() {
    const UNINIT: ::core::mem::MaybeUninit<sched_queue_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sched_queue_t>(),
        320usize,
        concat!("Size of: ", stringify!(sched_queue_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sched_queue_t>(),
        8usize,
        concat!("Alignment of ", stringify!(sched_queue_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_queue_t),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cpu_exec_proc_jiffies) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_queue_t),
            "::",
            stringify!(cpu_exec_proc_jiffies)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).proc_queue) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_queue_t),
            "::",
            stringify!(proc_queue)
        )
    );
}
extern "C" {
    pub static mut sched_cfs_ready_queue: [sched_queue_t; 32usize];
}
extern "C" {
    #[doc = " @brief 调度函数"]
    #[doc = ""]
    pub fn sched_cfs();
}
extern "C" {
    #[doc = " @brief 将PCB加入就绪队列"]
    #[doc = ""]
    #[doc = " @param pcb"]
    pub fn sched_cfs_enqueue(pcb: *mut process_control_block);
}
extern "C" {
    #[doc = " @brief 从就绪队列中取出PCB"]
    #[doc = ""]
    #[doc = " @return struct process_control_block*"]
    pub fn sched_cfs_dequeue() -> *mut process_control_block;
}
extern "C" {
    #[doc = " @brief 初始化CFS进程调度器"]
    #[doc = ""]
    pub fn sched_cfs_init();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sched_param {
    pub sched_priority: ::core::ffi::c_int,
}
#[test]
fn bindgen_test_layout_sched_param() {
    const UNINIT: ::core::mem::MaybeUninit<sched_param> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sched_param>(),
        4usize,
        concat!("Size of: ", stringify!(sched_param))
    );
    assert_eq!(
        ::core::mem::align_of::<sched_param>(),
        4usize,
        concat!("Alignment of ", stringify!(sched_param))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sched_priority) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_param),
            "::",
            stringify!(sched_priority)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sched_attr {
    pub size: u32,
    pub sched_policy: u32,
    pub sched_flags: u64,
    pub sched_nice: i32,
    pub sched_priority: u32,
    pub sched_runtime: u64,
    pub sched_deadline: u64,
    pub sched_period: u64,
    pub sched_util_min: u32,
    pub sched_util_max: u32,
}
#[test]
fn bindgen_test_layout_sched_attr() {
    const UNINIT: ::core::mem::MaybeUninit<sched_attr> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sched_attr>(),
        56usize,
        concat!("Size of: ", stringify!(sched_attr))
    );
    assert_eq!(
        ::core::mem::align_of::<sched_attr>(),
        8usize,
        concat!("Alignment of ", stringify!(sched_attr))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_attr),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sched_policy) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_attr),
            "::",
            stringify!(sched_policy)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sched_flags) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_attr),
            "::",
            stringify!(sched_flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sched_nice) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_attr),
            "::",
            stringify!(sched_nice)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sched_priority) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_attr),
            "::",
            stringify!(sched_priority)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sched_runtime) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_attr),
            "::",
            stringify!(sched_runtime)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sched_deadline) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_attr),
            "::",
            stringify!(sched_deadline)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sched_period) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_attr),
            "::",
            stringify!(sched_period)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sched_util_min) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_attr),
            "::",
            stringify!(sched_util_min)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sched_util_max) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_attr),
            "::",
            stringify!(sched_util_max)
        )
    );
}
extern "C" {
    #[doc = " sched_setscheduler -设置进程的调度策略"]
    #[doc = " @param p 需要修改的pcb"]
    #[doc = " @param policy 需要设置的policy"]
    #[doc = " @param param structure containing the new RT priority. 目前没有用"]
    #[doc = ""]
    #[doc = " @return 成功返回0,否则返回对应的错误码"]
    #[doc = ""]
    pub fn sched_setscheduler(
        p: *mut process_control_block,
        policy: ::core::ffi::c_int,
        param: *const sched_param,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief 包裹sched_enqueue(),将PCB加入就绪队列"]
    #[doc = ""]
    #[doc = " @param pcb"]
    pub fn sched_enqueue(pcb: *mut process_control_block);
}
extern "C" {
    #[doc = " @brief 包裹sched_cfs()，调度函数"]
    #[doc = ""]
    pub fn sched();
}
extern "C" {
    pub fn sched_init();
}
extern "C" {
    #[doc = " @brief 当时钟中断到达时，更新时间片"]
    #[doc = ""]
    pub fn sched_update_jiffies();
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::core::ffi::c_uint,
    pub fp_offset: ::core::ffi::c_uint,
    pub overflow_arg_area: *mut ::core::ffi::c_void,
    pub reg_save_area: *mut ::core::ffi::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    const UNINIT: ::core::mem::MaybeUninit<__va_list_tag> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::core::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).gp_offset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fp_offset) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).overflow_arg_area) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg_save_area) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
