
use core::hash::{Hash,Hasher,SipHasher};

use alloc::{collections::{linked_list::Cursor, LinkedList}, sync::{Arc, Weak}};
use system_error::SystemError;

use super::IndexNode;

// pub trait Cachable: Eq + 

#[derive(Debug)]
pub struct DCache<'a, T: IndexNode + ?Sized> {
    curr_size: usize,
    capacity: usize,
    arr: Vec<
            LinkedList<
                Cursor< 'a, (String, Weak<T>) >
            >>,
    lru: LinkedList< (String, Weak<T>) >,
}

// Todo: according to memery capacity to decide size.

impl<'a, T: IndexNode + ?Sized> DCache<'a, T> {
    const DEFAULT_MAX_SIZE: u64 = 1024;
    const DEFAULT_HASH_SIZE: u64 = 512;

    fn position(key: &str) -> u64 {
        let mut hasher = SipHasher::new();
        key.hash(&mut hasher);
        hasher.finish() % Self::DEFAULT_HASH_SIZE
    }

    pub fn new(capacity: Option<usize>) -> DCache<'a, T> {
        let mut ret = DCache {
            capacity: capacity.unwrap_or(Self::DEFAULT_MAX_SIZE as usize),
            curr_size: 0,
            arr: Vec::new(),
            lru: LinkedList::new(),
        };
        ret.arr.resize(
            Self::DEFAULT_MAX_SIZE as usize, 
            LinkedList::new()
        );

        ret
    }

    pub fn put(&mut self, name: &str, entry: &Arc<T>) -> Result<(), SystemError> {
        let position = Self::position(name) as usize;
        // check if exist


        // insert to lru queue
        self.lru.push_back( (String::from(name), Arc::downgrade(entry)) );

        // insert coresponding cursor
        self.arr[position as usize]
            .push_back(self.lru.cursor_back());

        Ok(())
    }

    pub fn get(&mut self, key: &str) -> Option<Arc<T>> {
        let list = self.arr[Self::position(key) as usize];
        list.iter().find(|cur| {
            if let Some(entry) = cur.current() {
                if entry.0 == key {
                    entry.1.upgrade()?
                        .parent()?
                        .
                }
            }
            return false;
        })
        



        // if let Some(entry) = self
        //     .arr[Self::position(key) as usize].entry.clone() {
        //     if let Some(ex) = entry.upgrade() {
        //         self.arr[Self::position(key) as usize].count += 1;
        //         return Some(ex);
        //     }
        // }
        None
    }

    pub fn remove(&mut self, key: &str) {
        self
            .arr[Self::position(key) as usize]
            .entry
            .take();
    }

    pub fn clear(&mut self) {
        // overwrite the array to yeet everything
        self.curr_size = 0;
        self.arr = [Self::INIT; DEFAULT_MAX_SIZE];
    }

}
